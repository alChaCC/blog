<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | AlohaCC]]></title>
  <link href="http://ccaloha.cc/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://ccaloha.cc/"/>
  <updated>2015-02-26T16:43:01+08:00</updated>
  <id>http://ccaloha.cc/</id>
  <author>
    <name><![CDATA[Aloha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Ruby on Rails] Model Version control using papertrail]]></title>
    <link href="http://ccaloha.cc/blog/2015/02/26/model-version-control-using-papertrail/"/>
    <updated>2015-02-26T16:30:53+08:00</updated>
    <id>http://ccaloha.cc/blog/2015/02/26/model-version-control-using-papertrail</id>
    <content type="html"><![CDATA[<h2>Why use papertrail ?</h2>

<p><img src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/Rails%E5%8A%A0%E5%85%A5Model%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202015-01-06%20%E4%B8%8A%E5%8D%8811.57.23.png" alt="ruby toolbox - active record versioning"></p>

<h2>Step1. Add lib</h2>

<p><strong>Gemfile</strong></p>

<pre><code>gem 'paper_trail', '~&gt; 3.0.6'
</code></pre>

<h2>Step2. create a migration</h2>

<p><strong>On Terminal</strong></p>

<pre><code>bundle exec rails generate paper_trail:install
</code></pre>

<p>他會建立，一個叫做<strong>versions</strong>的表</p>

<h2>Step3. migrate</h2>

<pre><code>bundle exec rake db:migrate
</code></pre>

<h2>Step4. Done</h2>

<p>把 <strong>has_paper_trail</strong> 加上你想要追蹤的model</p>

<h2>應用部分</h2>

<h3>若是想要不同model使用不同追蹤table?</h3>

<p>假設我想要<strong>product</strong>有自己的versions表</p>

<ul>
<li><p>Step1.</p>

<pre><code>  rails g model product_version 
</code></pre></li>
<li><p>貼上</p>

<pre><code>  class CreateProductVersions &lt; ActiveRecord::Migration
    def change
      create_table :product_versions do |t|
        t.string   :item_type, :null =&gt; false
        t.integer  :item_id,   :null =&gt; false
        t.string   :event,     :null =&gt; false
        t.string   :whodunnit
        t.text     :object
        t.datetime :created_at
        # t.string   :author_username 如果你需要自訂一些欄位讓他記錄，也可以在migration這邊加
      end
      add_index :product_versions, [:item_type, :item_id]
      end
    end
  end
</code></pre></li>
</ul>


<p>ps. 這就是他本身內建會產生的欄位，只是我們手動把它copy一份出來</p>

<ul>
<li><p>別忘了</p>

<pre><code>  bundle exec rake db:migrate
</code></pre></li>
<li><p>改model <strong>ProductVersion</strong></p>

<pre><code>  class ProductVersion &lt; PaperTrail::Version
    self.table_name = :product_versions
  end
</code></pre></li>
<li><p>改model <strong>Product</strong></p>

<pre><code>  class Product &lt; ActiveRecord::Base
      ...
      has_paper_trail class_name: 'ProductVersion'
      ...
  end
</code></pre></li>
</ul>


<h3>若是想要知道誰動了資料?</h3>

<p> 假設你有使用<strong>devise</strong>，然後是寫在後台</p>

<p>請加在 <strong>controller/admin/admin_controller.rb</strong></p>

<pre><code>def user_for_paper_trail
    admin_signed_in? ? current_admin.email : 'System'
end
</code></pre>

<p>假使你在前台，你可能需要這樣寫</p>

<pre><code>def user_for_paper_trail
    user_signed_in? ? current_user.email : 'Public User'
end
</code></pre>

<h3>若某個動作不想被追蹤</h3>

<pre><code>@product.without_versioning do
  @product.update_attributes :created_at =&gt; Time.now
end
</code></pre>

<h3>若要刪除某個versions從哪天到某天</h3>

<p>方法一：<strong>下SQL</strong></p>

<pre><code>delete from versions where created_at &lt; 2014-01-01;
</code></pre>

<p>方法二：<strong>在rails c底下</strong></p>

<pre><code>PaperTrail::Version.delete_all ["created_at &lt; ?", 1.year.ago]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Analytics - Cross Device tracking in Ruby on Rails]]></title>
    <link href="http://ccaloha.cc/blog/2014/12/12/google-analytics-cross-device-tracking-in-ruby-on-rails/"/>
    <updated>2014-12-12T08:13:38+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/12/12/google-analytics-cross-device-tracking-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>首先，先來看一下google 的說明</p>

<iframe width="560" height="315" src="http://ccaloha.cc//www.youtube.com/embed/RsrAcxIsQHU" frameborder="0" allowfullscreen></iframe>




<!-- more -->


<blockquote><p>簡單來說，GA 在不同裝置瀏覽時，會依照每個裝置製作特別的ID, 但是，當user清掉Cookie或是重新安裝機器，就會把那個特別的ID重設，這樣他就會變成新訪客，而不是回流訪客。</p></blockquote>

<p>當然，如果要跨Devise追蹤，既然是不同的Devise當然它的ID一定不一樣，所以一個使用者如果用電腦先在Urcosme網頁看一下等一下想要購買的商品，之後，他出發到康是美，要買產品之前拿出手機，再看一次商品確認，基本上他就會被列為兩個不同的來源</p>

<p>所以要跨Device追蹤，很重要的關鍵是：</p>

<blockquote><p>那個特別的ID</p></blockquote>

<p>然而，Universal(新版)的GA有提供修改 user id的功能！</p>

<p><a href="http://cutroni.com/blog/2014/04/10/understanding-cross-device-measurement-and-the-user-id/">Understanding Cross Device Measurement and the User-ID</a></p>

<h2>那要怎麼加上user id 呢？</h2>

<h3>Step1. 第一步，打開User ID的功能</h3>

<p><img alt="GA User ID" src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/GA/user%20id%20%E5%95%9F%E7%94%A8.png"></img></p>

<h3>Step2. 改網站上的Code</h3>

<p><img alt="GA User ID code" src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/GA/%E8%A8%AD%E5%AE%9AUser_id%20.png"></p>

<h3>Step3. 設定View名稱！</h3>

<p>恭喜你 就有新的View !</p>

<h3>Step4. Rails 要怎麼加入 User ID呢？</h3>

<p>如果你跟我一樣是使用Devise gem作為登入的lib，</p>

<h4>Step 1. 在 app/views/layouts/application.html.slim 加上</h4>

<pre><code>= render 'shared/google_analytics', user_id: current_user.try(:id) 
</code></pre>

<p>ps. 若是使用 partial</p>

<pre><code>= render :partial =&gt; "partials/google_analytics" , :locals =&gt; { user_id: current_user.try(:id)}
</code></pre>

<p><em>重點就是那user_id，如果不用try的話，若是current_user是nil，就會報錯！</em></p>

<h4>Step 2. 編輯 app/views/shared/_google_analytics.html.erb</h4>

<pre><code>&lt;script&gt;

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  &lt;%- if user_id.present? %&gt;
    ga('create', 'UA-XXXX-YYYY', {'userId': '&lt;%= user_id %&gt;'})
  &lt;%- else %&gt;
    ga('create', 'UA-XXXX-Y', 'urbox.cc');
  &lt;% end %&gt;
  ga('send', 'pageview');

&lt;/script&gt;
</code></pre>

<h3>那假設user沒有登入，你沒有辦法給他user id</h3>

<p>Google 有推出(工作階段整合) Session Unification的功能，當你啟動了這個功能後，基本上有User ID的就會被放在一個群組，沒有User ID的就會在另外一個群組！</p>

<p>但是厲害的是，Google在同一個session內，若發現這個ID(隨機產生)被重新assign過(系統assign)，他會把之前的action記錄給後來的ID</p>

<h2>那套上User ID後，會有什麼差別呢？</h2>

<ol>
<li><p> 你的指標(metrics)計算方式不同，但是更精確了！</p></li>
<li><p> 你擁有了跨裝置的報告.</p></li>
<li><p> Limited date range.</p></li>
</ol>


<p>  你的Data範圍是90天。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HOWTO]- 在Ruby on Rails 實作Ckeditor上傳圖片到各個獨立的資料夾]]></title>
    <link href="http://ccaloha.cc/blog/2014/12/10/howto-setup-ckeditor-upload-picture-to-a-special-folder-in-ruby-on-rails/"/>
    <updated>2014-12-10T08:04:05+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/12/10/howto-setup-ckeditor-upload-picture-to-a-special-folder-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>首先，要先感謝 <strong><em>Ayaya</em></strong>，主要是參考他的code而改編出來的功能！</p>

<p>一樣講一下需求</p>

<p>我希望使用者上傳檔案到不同特定的資料夾，譬如：A新聞的照片，只會被上傳到A新聞的資料夾</p>

<p><img src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/%5BHOWTO%5D-%20%E5%9C%A8Ruby%20on%20Rails%20%E5%AF%A6%E4%BD%9CCkeditor%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E5%88%B0%E5%90%84%E5%80%8B%E7%8D%A8%E7%AB%8B%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%BE/Ckeditor_upload_image_to_specific_folder.png" alt='ckeditor 上傳圖片到特定資料夾'></p>

<p>之後你還可以實作 照片只能被特定使用者看到，這篇文章就不在這邊琢磨</p>

<!--more-->


<p>另外這篇文章，我不會提到 <strong>Ckedior</strong> 的基本安裝的東西，有興趣的話，請看 <strong><a href="https://github.com/galetahub/ckeditor">Github</a></strong></p>

<p>上傳的部分我是使用 <strong><a href="https://github.com/galetahub/ckeditor#activerecord--carrierwave">ActiveRecord + Carrierwave</a></strong></p>

<h2>Step1. Migration</h2>

<p>首先，我們先從model開始，當你跑完</p>

<pre><code>rails generate ckeditor:install --orm=active_record --backend=carrierwave
</code></pre>

<p>會幫你建立model，以我的case來說，會建立<strong><em>db/migrate/20141204171531_create_ckeditor_assets.rb</em></strong></p>

<p>在這邊，我要先另外加入</p>

<pre><code>  t.integer :owner_id 
  t.string  :owner_type, :limit =&gt; 30  
</code></pre>

<p>其中<strong>owner_type</strong>是要記錄哪個model</p>

<p><strong>owner_id</strong>是要記錄model的ID</p>

<p>舉例來說，如果你的建立產品上稿，會被記錄到 model 的就是：<strong>Product</strong>，另外ID可能是：<strong>999</strong></p>

<p>所以記錄到 owner_type 就會是 "Product" ，另外owner_id 就是："999"</p>

<p>最後別忘記，</p>

<pre><code>rake db:migrate
</code></pre>

<h2>Step2. [Important] Controller</h2>

<p>接下來步驟，會有點麻煩</p>

<p>因為我不想要用ckeditor 預設的 <strong>pictures_controller.rb</strong> 來處理上傳的動作，所以....</p>

<p>來看一下，麻煩點在於</p>

<p>我們是後台需要實作 ckeditor，所以controller要放在 <strong>/cooladmin/</strong> 裡面</p>

<p>這個...搞了我超久，不過也是因為這樣，讓我比較了解這個機制</p>

<p>好吧！ 那就開始吧！！！</p>

<pre><code>rails g controller cooladmin/ckeditor_pictures
</code></pre>

<h3>首先這個controller 必需繼承 <strong>Ckeditor::PicturesController</strong></h3>

<p>所以...</p>

<pre><code>class Cooladmin::CkeditorPicturesController &lt; Ckeditor::PicturesController
</code></pre>

<p>那這個<strong><a href="https://github.com/galetahub/ckeditor/blob/master/app/controllers/ckeditor/pictures_controller.rb">Ckeditor::PicturesController</a></strong>原本怎麼寫，就請看他們官網</p>

<p>由於我們不希望使用ckeditor 的before_action，所以，我們這邊都把它skip掉</p>

<pre><code>skip_before_filter :find_asset
skip_before_filter :ckeditor_authorize!
skip_before_filter :authorize_resource
</code></pre>

<h3>第一個action : <strong>index</strong></h3>

<p>這個是給當使用者點選"瀏覽伺服器"時呼叫的</p>

<p><img src='https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/%5BHOWTO%5D-%20%E5%9C%A8Ruby%20on%20Rails%20%E5%AF%A6%E4%BD%9CCkeditor%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E5%88%B0%E5%90%84%E5%80%8B%E7%8D%A8%E7%AB%8B%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%BE/ckeditor_controller_index_target_1.png'></p>

<p>我的寫法是：</p>

<pre><code>def index
  @pictures = Ckeditor::Paginatable.new(pictures).page(params[:page])
  respond_with(@pictures,layout: @pictures.first_page?)
end 
</code></pre>

<p>那 <strong>pictures</strong> 這個從那裡來？</p>

<pre><code>private

  def pictures
    @pictures ||= if owner
                Ckeditor::CkeditorPicture.by_owner(owner)
                    else
                    Ckeditor::CkeditorPicture.orphan
                    end
  end

  def owner
    @owner ||=  case 
                when params[:owner_type].present? &amp;&amp; params[:owner_id].present? 
                  params[:owner_type].singularize.classify.constantize.find(params[:owner_id])
                else
                  nil
                end
  end
</code></pre>

<p>ps. <strong>Ckeditor::CkeditorPicture.by_owner(owner)</strong> 這個model是我改裝model，下個章節會介紹，by_owner就是去拿到屬於這個owner的image，那owner怎麼來呢？</p>

<p>主要透過 url 取得目前是在哪個model的哪個ID被啟動ckeditor，這樣的話，就只會去抓屬於這個modal和他所屬的id，以下面那個url為例，他會去找ckeditor_assets裡頭的屬於<strong>owner_type</strong>為<strong>Product</strong>以及<strong>owner_id</strong>為<strong>1</strong>的所有照片</p>

<p><strong> https://XXX.XXX.XXX/cooladmin/ckeditor_pictures?owner_id=2&amp;owner_type=Product&amp;CKEditor=product_content&amp;CKEditorFuncNum=1&amp;langCode=zh </strong></p>

<h3>第二個action : <strong>create</strong></h3>

<p>照片上傳上來後，透過這個action去接</p>

<pre><code>def create
  if owner.present?
    @picture = Ckeditor::CkeditorPicture.new(owner: @owner) 
  else
    @picture = Ckeditor::CkeditorPicture.new(owner_type: params[:owner_type]) 
  end
  respond_with_asset(@picture)
end
</code></pre>

<p>判斷如果 有owner存在的話，就把這個照片new進去，並設定owner進去</p>

<p>不然的話，就在建立照片時，就只設定<strong>owner_type</strong> (這邊有個問題，我還不知道怎麼解決，所以只好先丟個owner_type給他)</p>

<h3>第三個action : <strong>destroy</strong></h3>

<p>很明顯就是去刪除照片～但是.....基本上這個方法不會被呼叫到....因為ckeditor會default去找</p>

<p>因為我們儲存到 <strong>ckeditor_assets</strong> table時，有一個欄位是 <strong>type</strong>，因為我們在new還有create時用的是 <strong>Ckeditor::CkeditorPicture.new(owner: @owner)</strong> 所以他的type就會是....<strong>Ckeditor::CkeditorPicture</strong>，所以在刪除的時候，
他default會去找有沒有這個controller => <strong>app/controllers/ckeditor_pictures_controller.rb</strong></p>

<p>這樣當然是沒有，因為我們是寫在 /cooladmin/底下啊～～～</p>

<p>所以...小弟我很弱，還不知道怎麼解....所以只好copy一份出來....</p>

<pre><code>def destroy
  @picture ||= Ckeditor::CkeditorPicture.find(params[:id])
  @picture.destroy
  respond_with(@picture,location: pictures_path)
end
</code></pre>

<p>完整版：<strong>app/controllers/cooladmin/ckeditor_pictures_controller.rb</strong></p>

<p>基本上這個contoller，我是直接copy一份到<strong>app/controllers/ckeditor_pictures_controller.rb</strong></p>

<pre><code>class Cooladmin::CkeditorPicturesController &lt; Ckeditor::PicturesController
  skip_before_filter :find_asset
  skip_before_filter :ckeditor_authorize!
  skip_before_filter :authorize_resource

  def index
    @pictures = Ckeditor::Paginatable.new(pictures).page(params[:page])
    respond_with(@pictures,layout: @pictures.first_page?)
  end

  def create
    if owner.present?
      @picture = Ckeditor::CkeditorPicture.new(owner: @owner) 
    else
      @picture = Ckeditor::CkeditorPicture.new(owner_type: params[:owner_type]) 
    end
    respond_with_asset(@picture)
  end

  def destroy
    @picture ||= Ckeditor::CkeditorPicture.find(params[:id])
    @picture.destroy
    respond_with(@picture,location: pictures_path)
  end

  private

  def pictures
    @pictures ||= if owner
                    Ckeditor::CkeditorPicture.by_owner(owner)
                  else
                    Ckeditor::CkeditorPicture.myupload_orphan(current_employee)
                  end
  end


  def owner
    @owner ||=  case 
                when params[:owner_type].present? &amp;&amp; params[:owner_id].present? 
                  params[:owner_type].singularize.classify.constantize.find(params[:owner_id])
                else
                  nil
                end
  end

end
</code></pre>

<h2>Step3. [Important] Model</h2>

<p>這邊我是直接改ckeditor幫我產生的model <strong>models/ckeditor/picture.rb</strong></p>

<p>我把它改成 <strong>models/ckeditor/ckeditor_picture.rb</strong></p>

<pre><code>mv models/ckeditor/picture.rb models/ckeditor/ckeditor_picture.rb
</code></pre>

<p>幾個重點：</p>

<ul>
<li>因為這個picture基本上會隸屬於不同的model 然後他們之間都是透過 owner來做type</li>
</ul>


<p>所以</p>

<pre><code>belongs_to :owner, polymorphic: true
</code></pre>

<ul>
<li>幾個簡單scope</li>
</ul>


<p>在看這個scope我們來看一下，db裡面存的主要欄位內容</p>

<table>
<thead>
<tr>
<th></th>
<th> assetable_id </th>
<th> assetable_type </th>
<th> type                      </th>
<th> owner_id </th>
<th> owner_type </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 1            </td>
<td> Employee       </td>
<td> Ckeditor::CkeditorPicture </td>
<td> 2        </td>
<td> Product    |</td>
</tr>
</tbody>
</table>


<p>assetable_type => 這個資料的上傳者class</p>

<p>type      => 這張照片是哪個model new進來的</p>

<p>owner_type    => 這張照片被用在哪個class下</p>

<p>看完表格就知道我的scope在幹嘛了～</p>

<pre><code>scope :myupload_orphan, -&gt; (employee_id) {where(assetable_id: employee_id, owner_id: nil)}
scope :by_owner_type, -&gt; (owner,employee_id) {where(owner_type: owner.class.name, owner_id: nil, assetable_id: employee_id)}
scope :by_owner, -&gt; (owner) { where(owner_id: owner.id)}
</code></pre>

<p>完整程式：</p>

<pre><code>class Ckeditor::CkeditorPicture &lt; Ckeditor::Asset
  belongs_to :owner, polymorphic: true
  mount_uploader :data, CkeditorPictureUploader, :mount_on =&gt; :data_file_name

  scope :myupload_orphan, -&gt; (employee_id) {where(assetable_id: employee_id, owner_id: nil)}
  scope :by_owner_type, -&gt; (owner,employee_id) {where(owner_type: owner.class.name, owner_id: nil, assetable_id: employee_id)}
  scope :by_owner, -&gt; (owner) { where(owner_id: owner.id)}

  def url_content
    url(:content)
  end
end
</code></pre>

<h2>Step4. 修改ckeitor 設定</h2>

<p>我是使用coffeescript</p>

<pre><code>$(document).on 'ready page:load', -&gt;
  $('[data-content-editor]').each -&gt;
    $this = $(this)
    CKEDITOR.replace(
      this
      allowedContent: true

  # 設定要處理image處理
      filebrowserImageBrowseUrl: $this.data('upload-url')

      filebrowserImageUploadUrl: $this.data('upload-url')
    )
</code></pre>

<h2>Step5. 修改用到ckeditor的View</h2>

<p>我是使用simple_form</p>

<pre><code>= f.input :content, label: '內容', input_html: { class: 'form-control', data: {content_editor: true, upload_url: upload_url_for(@product)} } 
</code></pre>

<p>upload_url_for請看下面</p>

<h2>Step6. helper</h2>

<p>寫這個helper的原因是因為我希望不同的model都可以使用</p>

<p><strong>app/helpers/cooladmin/admin_helper.rb</strong></p>

<pre><code>module Cooladmin::AdminHelper
  def upload_url_for(resource)
    if resource.new_record?
      cooladmin_ckeditor_pictures_path(:owner_type =&gt; resource.class.name)
    else
      cooladmin_ckeditor_pictures_path(:owner_type =&gt; resource.class.name, :owner_id =&gt; resource.id)
    end
  end
end
</code></pre>

<h2>Step7. Route</h2>

<pre><code>Rails.application.routes.draw do
  # mount Ckeditor::Engine =&gt; '/uradmin/ckeditor'

  resources :ckeditor_pictures, only: [:index, :create, :destroy]

  namespace :cooladmin do
    # ....略
    # ckeditor使用
    resources :ckeditor_pictures, only: [:index, :create, :destroy]
  end

end
</code></pre>

<h2>完成！！！！！！！！！！！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HowTo] - Implement autocomplete feature in elasticsearch using soulmate.js in Ruby on Rails application]]></title>
    <link href="http://ccaloha.cc/blog/2014/12/03/howto-implement-autocomplete-feature-in-elasticsearch-using-soulmate-dot-js-in-ruby-on-rails-application/"/>
    <updated>2014-12-03T07:50:57+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/12/03/howto-implement-autocomplete-feature-in-elasticsearch-using-soulmate-dot-js-in-ruby-on-rails-application</id>
    <content type="html"><![CDATA[<p>先說明一下需求，你希望使用者在搜尋框框打字的時，希望可以給他推薦就像....</p>

<p><img alt="elasticsearch autocomple sample" src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/%5BHowTo%5D%20-%20Implement%20autocomplete%20feature%20in%20elasticsearch%20using%20soulmate.js%20in%20Ruby%20on%20Rails%20application/f1.png"></p>

<p>故這篇文章，你可以知道，如何透過elasticsearch 達成 自動化推薦的功能！</p>

<p>以及 如何將此功能與 soulmate.js結合 (因為我之前是用soulmate來實作，但是會推薦的詞，一定是user有打過有搜尋過的字)</p>

<!-- more -->


<h2>Step0. 你可以先玩看看 soulmate.js</h2>

<p><a href="http://josephndungu.com/tutorials/fast-autocomplete-search-terms-rails">FAST AUTOCOMPLETE SEARCH TERMS - RAILS</a></p>

<p>另外這篇主要是參考</p>

<p><a href="https://shellycloud.com/blog/2013/10/adding-search-and-autocomplete-to-a-rails-app-with-elasticsearch">Adding search and autocomplete to a Rails app with Elasticsearch</a></p>

<h2>Step1. Searchkick</h2>

<p>下面加入到 <strong><em>Gemfile</em></strong>:</p>

<pre><code>gem 'searchkick'
</code></pre>

<h2>Step2. Routing</h2>

<p>因為我是要在產品搜尋時做自動推薦，所以在product的routing 加上 autocomplete</p>

<p>下面加入到 <strong><em>config/routes.rb</em></strong></p>

<pre><code>  #下面那行之前沒有elasticsearch幫忙，直接用soulmate實作時的做法
  #mount Soulmate::Server, :at =&gt; "/autocomplete" 

  resources :products do
    collection do
      get :autocomplete
      get :search
    end
  end 
</code></pre>

<h2>Step3. Model</h2>

<p>為了要吐給soulmate json (你可以參考：https://github.com/seatgeek/soulmate#loading-items)</p>

<p>下面加上在<strong><em>app/models/product.rb</em></strong></p>

<pre><code># 讓elasticsearch知道這兩個欄位要做autocomplete功能(他會針對這兩個欄位做不一樣的index)
searchkick autocomplete: ['name', 'description']


# 到時候要吐給soulmate的json格式，你可以參考：https://github.com/seatgeek/soulmate#loading-items)

def to_soulmate
    {
      "term" =&gt; "#{brand.name}-#{name}",
      "id" =&gt; "#{product_id}",
      "score" =&gt; "",
      "data" =&gt; {
        "link" =&gt; "/product_searchs/product?keyword=#{name}"
      }
    }
end
</code></pre>

<p>另外我有create 一個<strong>keyword</strong>的model這邊就不特別說了～controller會用到</p>

<h2>Step4. Controller</h2>

<p>關鍵！</p>

<p>加在 <strong><em>app/controllers/products_controller.rb</em></strong></p>

<pre><code>def autocomplete
    # searchkick做autocomplete
    @products = Product.search params[:term], limit: 10, fields: [{"description" =&gt; :word},{"name" =&gt; :word}]

    # 為了拼出讓soulmate知道的url
    callback_str = params[:callback]
    return_data = {
        "term" =&gt;  "#{params[:term]}", 
        "results" =&gt; {
            "keyword" =&gt;  @products.map(&amp;:to_soulmate)
        }
    }
    # 以下是為了拼出給soulmate的callback
    render json: callback_str + "(" + "#{return_data.to_json}" + ")"
end

def search
    if params[:keyword].present?
        @products = Product.searchkick(params[:keyword],sort,search_page)

        if @products.present?
            @keyword = Keyword.find_or_create_by(name: "#{params[:keyword]}") do |k|
                k.score = 0
                k.url = "/products/search?keyword=#{params[:keyword]}"
                k.keyword_type = "Keyword"
            end
            @keyword.update_attribute(:score, @keyword.score+=1) #代表多搜尋了一次
            # remove_from_soulmate(@keyword) #已用不到
            # load_into_soulmate(@keyword)  #已用不到
        end
    end
end

def load_into_soulmate(keyword)
    loader = Soulmate::Loader.new("#{keyword.keyword_type}")
    loader.add("term" =&gt; keyword.name, "id" =&gt; keyword.id, "score" =&gt; keyword.score, "data" =&gt; { "link" =&gt; "#{keyword.url}"})
end

def remove_from_soulmate(keyword)
    loader = Soulmate::Loader.new("#{keyword.keyword_type}")
  loader.remove("id" =&gt; keyword.id)
end
</code></pre>

<p>這邊很重要的是，你使用soulmate.js去做autocomplete時，他會丟出一串callback給server，基本上你的response也要包含這個callback，我覺得很像jsonp</p>

<p>[注意！] 我把load_into_soulmate還有remove_from_soulmate留著只是單純給你看之前的做法，</p>

<p>但是我還是有保留keyword的model這樣我才知道哪些關鍵字被打了最多次！(當然你可以用GA但是由於隱私權設定，你很多會看到not provided....囧)</p>

<h2>Step5. View</h2>

<p>加上你想要搜尋的頁面，我們希望使用者可以在所有網頁都看到，所以是放在</p>

<p><strong><em>app/views/layouts/application.html.slim</em></strong></p>

<pre><code>= text_field_tag 'keyword', '輸入產品關鍵字', class: "form-control"
= button_tag "搜尋", id: "product_search", class: "btn btn-default"
</code></pre>

<h2>Step6. javascript</h2>

<pre><code># 這是要給product_search點擊後使用
$("#product_search").click(function(){
    window.location = '&lt;%= search_products_path %&gt;?keyword=' + $("#keyword").val();
})

#這是soulmate用法：注意我把url改掉了！
$('#keyword').soulmate({
    url: '/products/autocomplete',
    types: ['product','review','keyword'],
    renderCallback : render,
    selectCallback : select,
    minQueryLength : 1,
    maxResults     : 10,
    timeout:    5000
})
</code></pre>

<h2>完成！！！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HOWTO] Using ElasticSearch in Ruby on Rails and setup remote ES server via Vagrant]]></title>
    <link href="http://ccaloha.cc/blog/2014/11/27/howto-using-elasticsearch-in-ruby-on-rails-and-setup-remote-es-server-via-vagrant/"/>
    <updated>2014-11-27T07:45:20+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/11/27/howto-using-elasticsearch-in-ruby-on-rails-and-setup-remote-es-server-via-vagrant</id>
    <content type="html"><![CDATA[<p>首先，要先感謝 "老王"，和 "Marz"哥，給我參考他們的Elasticsearch的文件！</p>

<p>安裝部分，就是參考他們的操作！</p>

<p>這邊最主要的不一樣，是設定遠端的Elasticsearch機器！</p>

<p>改天我會補上 如何實作 "搜尋字詞推薦"，而且是整合soulmate歐！！</p>

<!-- more -->


<h2>Mac本機開發</h2>

<h3>安裝 elastic search</h3>

<pre><code>brew install elasticsearch
</code></pre>

<h3>連結</h3>

<pre><code>ln -sfv /usr/local/opt/elasticsearch/*.plist ~/Library/LaunchAgents
</code></pre>

<h3>啟動</h3>

<pre><code>launchctl load ~/Library/LaunchAgents/homebrew.mxcl.elasticsearch.plist
</code></pre>

<h3>關閉</h3>

<pre><code>launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.elasticsearch.plist
</code></pre>

<h3>Run ElasticSearch</h3>

<pre><code>export JAVA_HOME="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home"
elasticsearch

(或是)

elasticsearch --config=/usr/local/opt/elasticsearch/config/elasticsearch.yml  
</code></pre>

<h3>測試是否安裝成功</h3>

<pre><code>curl -X GET http://localhost:9200
</code></pre>

<p>你應該會看到</p>

<pre><code>{
  "status" : 200,
  "name" : "Rage",
  "version" : {
    "number" : "1.3.2",
    "build_hash" : "dee175dbe2f254f3f26992f5d7591939aaefd12f",
    "build_timestamp" : "2014-08-13T14:29:30Z",
    "build_snapshot" : false,
    "lucene_version" : "4.9"
  },
  "tagline" : "You Know, for Search"
}
</code></pre>

<h3>Code 要加入</h3>

<p>新增一個檔案</p>

<p><strong>lib/tasks/elasticsearch.rake</strong></p>

<p>寫入</p>

<pre><code>require 'elasticsearch/rails/tasks/import'
</code></pre>

<p>修改<strong>Gemfile</strong>，加入</p>

<pre><code>gem 'elasticsearch-rails'
gem 'elasticsearch-model' 
</code></pre>

<h3>跑index</h3>

<p>詳情請參考：<strong>Gem: </strong><a href="https://github.com/elasticsearch/elasticsearch-rails/tree/master/elasticsearch-rails">elasticsearch-rail</a></p>

<pre><code>bundle exec rake environment elasticsearch:import:all
</code></pre>

<p>如果只需要import一個model</p>

<pre><code>bundle exec rake environment elasticsearch:import:model CLASS='Article'
</code></pre>

<p>如果只需要import某些特定的scope</p>

<pre><code>bundle exec rake environment elasticsearch:import:model CLASS='Article' SCOPE='published'
</code></pre>

<h3>清除index</h3>

<pre><code>Article.__elasticsearch__.client.indices.delete index: Article.index_name rescue nil
</code></pre>

<h2>安裝elasticsearch 在Ubuntu 裡面</h2>

<h3>使用vagrant 起三檯機器(用來模擬正式環境)</h3>

<p>請查看前半部</p>

<p><a href="http://ccaloha.cc/blog/2014/09/19/howto-using-sunspot-access-remote-solr-instance-ubuntu-14-dot-04-in-ruby-on-rails-using-vagrant/">HOWTO - Using Sunspot to Access Remote Solr instance(Ubuntu 14.04) in Ruby on Rails Using Vagrant</a></p>

<h3>安裝 elascticsearch</h3>

<pre><code>vagrant ssh search 
sudo apt-get install openjdk-7-jre-headless -y
sudo wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -
</code></pre>

<h3>編輯source list</h3>

<pre><code>sudo vim /etc/apt/sources.list
</code></pre>

<p>把下面的code放進去</p>

<pre><code>  deb http://packages.elasticsearch.org/elasticsearch/1.3/debian stable main
</code></pre>

<p>繼續安裝</p>

<pre><code>  sudo apt-get update
  sudo apt-get install elasticsearch
  sudo update-rc.d elasticsearch defaults 95 10
  sudo /etc/init.d/elasticsearch start
</code></pre>

<h2>Ruby on Rails 部分</h2>

<h3>更改producion deploy的東東</h3>

<p><strong>config/deploy/production.rb</strong></p>

<pre><code>  role :app, %w{apps@33.33.13.10}
  role :web, %w{apps@33.33.13.10}
  role :db,  %w{apps@33.33.13.11}
  role :crontaber, %w{apps@33.33.13.10}
  set :rails_env, :production
  set :unicorn_rack_env, :production
  set :branch, 'feature/update_search_engine_to_elasticsearch'
</code></pre>

<p>我故意把ip改成 vagrant的ip</p>

<p>另外，branch也用成我自己測試的branch: <strong>feature/update_search_engine_to_elasticsearch</strong></p>

<h2>如何設定將elasticsearch 連到別台機器</h2>

<ol>
<li><p>新增一個 <strong>config/elasticsearch.yml</strong></p>

<pre><code> default: &amp;default
   host: 127.0.0.1:9200

 development:
   &lt;&lt;: *default
   host: 127.0.0.1:9200

 test:
   &lt;&lt;: *default

 production:
   &lt;&lt;: *default
   host: 33.33.13.12:9200
</code></pre></li>
<li><p>在application.rb加入</p>

<pre><code> es = YAML.load(File.open("#{Rails.root}/config/elasticsearch.yml"))[Rails.env]

   elasticsearch_config = {
       host: es["host"],
       transport_options: {
       request: { timeout: 5 }
       },
   }
   Elasticsearch::Model.client = Elasticsearch::Client.new(elasticsearch_config)
</code></pre></li>
<li><p>因為我的product需要做搜尋，所以在Product model 我這樣寫</p></li>
</ol>


<p>  (ps. elasticsearch 真的是博大精深，我沒有時間去深入專研，以下的指令是我try出最符合我需要的搜尋結果，所以大家可參考參考)</p>

<pre><code>def self.essearch(query,sort,page)
  if sort == 'relevance'

    results = __elasticsearch__.search(
      {
        query: {
          filtered: {
            filter: {
              range: { product_price_min: { "gt" =&gt; 0} }
             }, 
            query: {
              bool: {
                must: [
                  multi_match: {
                    query: query,
                    type:  "phrase",
                    fields: ["product_cname^10", "product_ename^10",'product_description', 'product_keyword']
                  }
                ]
              }
            }
          }
        },
        "sort" =&gt; [
          "_score",
          {"product_urcosme_exp" =&gt; {"order" =&gt; "desc"} } 
        ],
        "from" =&gt; (page.to_i-1)*5,
        "size" =&gt; 5          
      }
    )
  else
    # 因為不是精準搜尋，所以這邊的排序就真的會依照我們給他的sort，
    # 但是你總不希望，搜尋面膜，結果第一個結果是：淨膚儀，就因為他的上市時間最晚....囧～
    # 所以，我還是希望第一個看到的結果是以關鍵字有出現的為佳，所以我多使用了filter的功能
    results = __elasticsearch__.search(
      {
        query: {
          filtered: {
            filter: {
              range: { product_price_min: { "gt" =&gt; 0} }
             },
            filter: {
               exists: { field: "product_keyword" }
             },
            query: {
              bool: {
                must: [
                  multi_match: {
                    query: query,
                    type:  "cross_fields",
                    fields: ['product_cname', 'product_ename'],
                    operator:   "and", 
                    #minimum_should_match: '30%'
                  }
                ],
                should: [
                  { match: { "product_description" =&gt;  query}},
                  { match: { "product_keyword" =&gt; query }}
                ],
              }
            }
          }
        },
        "sort" =&gt; [
          {"#{sort}" =&gt; {"order" =&gt; "#{sort == "product_price_min"? 'asc' : 'desc'}"} } , 
           "_score",
          { "product_cname" =&gt; "desc" }
        ],
        "from" =&gt; (page.to_i-1)*5,
        "size" =&gt; 5        
      }
    )
  # 這邊目的是為了如果上面都沒有搜尋結果才做的比較rough的搜尋
  if results.results.size == 0
    results = __elasticsearch__.search(
      {
        query: {
          filtered: {
            filter: {
              range: { product_price_min: { "gt" =&gt; 0} }
             },
            query: {
              bool: {
                must: [
                  multi_match: {
                    query: query,
                    type:  "cross_fields",
                    fields: ['product_cname', 'product_ename','product_description','product_keyword'],
                    operator:   "and"
                  }
                ]
              }
            }
          }
        },
        "sort" =&gt; [
          {"#{sort}" =&gt; {"order" =&gt; "#{sort == "product_price_min"? 'asc' : 'desc'}"} } , 
           "_score",
          { "product_cname" =&gt; "desc" }
        ],
        "from" =&gt; (page.to_i-1)*5,
        "size" =&gt; 5          
      }
    )
  end
  end
  return results
end
</code></pre>

<ol>
<li><p>在product的controller</p>

<p>   @products = Product.essearch(params[:keyword],params[:sort],params[:page])</p>

<p>   @products =  search.results.results</p>

<p> 接下來就是丟給view顯示了～我就不提了～</p></li>
</ol>


<h3>接下來就是deploy加上看看有沒有成功摟</h3>

<pre><code>cap production deploy #因為"config/deploy/production.rb"有改成vagrant設定，所以請放心～
vagrant ssh search    # 登入你的搜尋機器
elasticsearch         # 把elasticsearch 服務跑起來
vagrant ssh app       # 登入跑服務的機器
cd 你的專案            
bundle exec rake environment elasticsearch:import:all  #跑index，這邊如果有成功，代表你已經連過去遠端了！
</code></pre>

<h3>完成！</h3>
]]></content>
  </entry>
  
</feed>
