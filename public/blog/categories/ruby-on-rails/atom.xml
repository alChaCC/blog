<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby_on_Rails | AlohaCC]]></title>
  <link href="http://ccaloha.cc/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://ccaloha.cc/"/>
  <updated>2014-12-10T12:46:06+08:00</updated>
  <id>http://ccaloha.cc/</id>
  <author>
    <name><![CDATA[Aloha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[HOWTO]- 在Ruby on Rails 實作Ckeditor上傳圖片到各個獨立的資料夾]]></title>
    <link href="http://ccaloha.cc/blog/2014/12/10/howto-setup-ckeditor-upload-picture-to-a-special-folder-in-ruby-on-rails/"/>
    <updated>2014-12-10T08:04:05+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/12/10/howto-setup-ckeditor-upload-picture-to-a-special-folder-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>首先，要先感謝 <strong><em>Ayaya</em></strong>，主要是參考他的code而改編出來的功能！</p>

<p>一樣講一下需求</p>

<p>我希望使用者上傳檔案到不同特定的資料夾，譬如：A新聞的照片，只會被上傳到A新聞的資料夾</p>

<p><img src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/%5BHOWTO%5D-%20%E5%9C%A8Ruby%20on%20Rails%20%E5%AF%A6%E4%BD%9CCkeditor%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E5%88%B0%E5%90%84%E5%80%8B%E7%8D%A8%E7%AB%8B%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%BE/Ckeditor_upload_image_to_specific_folder.png" alt='ckeditor 上傳圖片到特定資料夾'></p>

<p>之後你還可以實作 照片只能被特定使用者看到，這篇文章就不在這邊琢磨</p>

<!--more-->


<p>另外這篇文章，我不會提到 <strong>Ckedior</strong> 的基本安裝的東西，有興趣的話，請看 <strong><a href="https://github.com/galetahub/ckeditor">Github</a></strong></p>

<p>上傳的部分我是使用 <strong><a href="https://github.com/galetahub/ckeditor#activerecord--carrierwave">ActiveRecord + Carrierwave</a></strong></p>

<h2>Step1. Migration</h2>

<p>首先，我們先從model開始，當你跑完</p>

<pre><code>rails generate ckeditor:install --orm=active_record --backend=carrierwave
</code></pre>

<p>會幫你建立model，以我的case來說，會建立<strong><em>db/migrate/20141204171531_create_ckeditor_assets.rb</em></strong></p>

<p>在這邊，我要先另外加入</p>

<pre><code>  t.integer :owner_id 
  t.string  :owner_type, :limit =&gt; 30  
</code></pre>

<p>其中<strong>owner_type</strong>是要記錄哪個model</p>

<p><strong>owner_id</strong>是要記錄model的ID</p>

<p>舉例來說，如果你的建立產品上稿，會被記錄到 model 的就是：<strong>Product</strong>，另外ID可能是：<strong>999</strong></p>

<p>所以記錄到 owner_type 就會是 "Product" ，另外owner_id 就是："999"</p>

<p>最後別忘記，</p>

<pre><code>rake db:migrate
</code></pre>

<h2>Step2. [Important] Controller</h2>

<p>接下來步驟，會有點麻煩</p>

<p>因為我不想要用ckeditor 預設的 <strong>pictures_controller.rb</strong> 來處理上傳的動作，所以....</p>

<p>來看一下，麻煩點在於</p>

<p>我們是後台需要實作 ckeditor，所以controller要放在 <strong>/cooladmin/</strong> 裡面</p>

<p>這個...搞了我超久，不過也是因為這樣，讓我比較了解這個機制</p>

<p>好吧！ 那就開始吧！！！</p>

<pre><code>rails g controller cooladmin/ckeditor_pictures
</code></pre>

<h3>首先這個controller 必需繼承 <strong>Ckeditor::PicturesController</strong></h3>

<p>所以...</p>

<pre><code>class Cooladmin::CkeditorPicturesController &lt; Ckeditor::PicturesController
</code></pre>

<p>那這個<strong><a href="https://github.com/galetahub/ckeditor/blob/master/app/controllers/ckeditor/pictures_controller.rb">Ckeditor::PicturesController</a></strong>原本怎麼寫，就請看他們官網</p>

<p>由於我們不希望使用ckeditor 的before_action，所以，我們這邊都把它skip掉</p>

<pre><code>skip_before_filter :find_asset
skip_before_filter :ckeditor_authorize!
skip_before_filter :authorize_resource
</code></pre>

<h3>第一個action : <strong>index</strong></h3>

<p>這個是給當使用者點選"瀏覽伺服器"時呼叫的</p>

<p><img src='https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/%5BHOWTO%5D-%20%E5%9C%A8Ruby%20on%20Rails%20%E5%AF%A6%E4%BD%9CCkeditor%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E5%88%B0%E5%90%84%E5%80%8B%E7%8D%A8%E7%AB%8B%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%BE/ckeditor_controller_index_target_1.png'></p>

<p>我的寫法是：</p>

<pre><code>def index
  @pictures = Ckeditor::Paginatable.new(pictures).page(params[:page])
  respond_with(@pictures,layout: @pictures.first_page?)
end 
</code></pre>

<p>那 <strong>pictures</strong> 這個從那裡來？</p>

<pre><code>private

  def pictures
    @pictures ||= if owner
                Ckeditor::CkeditorPicture.by_owner(owner)
                    else
                    Ckeditor::CkeditorPicture.orphan
                    end
  end

  def owner
    @owner ||=  case 
                when params[:owner_type].present? &amp;&amp; params[:owner_id].present? 
                  params[:owner_type].singularize.classify.constantize.find(params[:owner_id])
                else
                  nil
                end
  end
</code></pre>

<p>ps. <strong>Ckeditor::CkeditorPicture.by_owner(owner)</strong> 這個model是我改裝model，下個章節會介紹，by_owner就是去拿到屬於這個owner的image，那owner怎麼來呢？</p>

<p>主要透過 url 取得目前是在哪個model的哪個ID被啟動ckeditor，這樣的話，就只會去抓屬於這個modal和他所屬的id，以下面那個url為例，他會去找ckeditor_assets裡頭的屬於<strong>owner_type</strong>為<strong>Product</strong>以及<strong>owner_id</strong>為<strong>1</strong>的所有照片</p>

<p><strong> https://XXX.XXX.XXX/cooladmin/ckeditor_pictures?owner_id=2&amp;owner_type=Product&amp;CKEditor=product_content&amp;CKEditorFuncNum=1&amp;langCode=zh </strong></p>

<h3>第二個action : <strong>create</strong></h3>

<p>照片上傳上來後，透過這個action去接</p>

<pre><code>def create
  if owner.present?
    @picture = Ckeditor::CkeditorPicture.new(owner: @owner) 
  else
    @picture = Ckeditor::CkeditorPicture.new(owner_type: params[:owner_type]) 
  end
  respond_with_asset(@picture)
end
</code></pre>

<p>判斷如果 有owner存在的話，就把這個照片new進去，並設定owner進去</p>

<p>不然的話，就在建立照片時，就只設定<strong>owner_type</strong> (這邊有個問題，我還不知道怎麼解決，所以只好先丟個owner_type給他)</p>

<h3>第三個action : <strong>destroy</strong></h3>

<p>很明顯就是去刪除照片～但是.....基本上這個方法不會被呼叫到....因為ckeditor會default去找</p>

<p>因為我們儲存到 <strong>ckeditor_assets</strong> table時，有一個欄位是 <strong>type</strong>，因為我們在new還有create時用的是 <strong>Ckeditor::CkeditorPicture.new(owner: @owner)</strong> 所以他的type就會是....<strong>Ckeditor::CkeditorPicture</strong>，所以在刪除的時候，
他default會去找有沒有這個controller => <strong>app/controllers/ckeditor_pictures_controller.rb</strong></p>

<p>這樣當然是沒有，因為我們是寫在 /cooladmin/底下啊～～～</p>

<p>所以...小弟我很弱，還不知道怎麼解....所以只好copy一份出來....</p>

<pre><code>def destroy
  @picture ||= Ckeditor::CkeditorPicture.find(params[:id])
  @picture.destroy
  respond_with(@picture,location: pictures_path)
end
</code></pre>

<p>完整版：<strong>app/controllers/cooladmin/ckeditor_pictures_controller.rb</strong></p>

<p>基本上這個contoller，我是直接copy一份到<strong>app/controllers/ckeditor_pictures_controller.rb</strong></p>

<pre><code>class Cooladmin::CkeditorPicturesController &lt; Ckeditor::PicturesController
  skip_before_filter :find_asset
  skip_before_filter :ckeditor_authorize!
  skip_before_filter :authorize_resource

  def index
    @pictures = Ckeditor::Paginatable.new(pictures).page(params[:page])
    respond_with(@pictures,layout: @pictures.first_page?)
  end

  def create
    if owner.present?
      @picture = Ckeditor::CkeditorPicture.new(owner: @owner) 
    else
      @picture = Ckeditor::CkeditorPicture.new(owner_type: params[:owner_type]) 
    end
    respond_with_asset(@picture)
  end

  def destroy
    @picture ||= Ckeditor::CkeditorPicture.find(params[:id])
    @picture.destroy
    respond_with(@picture,location: pictures_path)
  end

  private

  def pictures
    @pictures ||= if owner
                    Ckeditor::CkeditorPicture.by_owner(owner)
                  else
                    Ckeditor::CkeditorPicture.myupload_orphan(current_employee)
                  end
  end


  def owner
    @owner ||=  case 
                when params[:owner_type].present? &amp;&amp; params[:owner_id].present? 
                  params[:owner_type].singularize.classify.constantize.find(params[:owner_id])
                else
                  nil
                end
  end

end
</code></pre>

<h2>Step3. [Important] Model</h2>

<p>這邊我是直接改ckeditor幫我產生的model <strong>models/ckeditor/picture.rb</strong></p>

<p>我把它改成 <strong>models/ckeditor/ckeditor_picture.rb</strong></p>

<pre><code>mv models/ckeditor/picture.rb models/ckeditor/ckeditor_picture.rb
</code></pre>

<p>幾個重點：</p>

<ul>
<li>因為這個picture基本上會隸屬於不同的model 然後他們之間都是透過 owner來做type</li>
</ul>


<p>所以</p>

<pre><code>belongs_to :owner, polymorphic: true
</code></pre>

<ul>
<li>幾個簡單scope</li>
</ul>


<p>在看這個scope我們來看一下，db裡面存的主要欄位內容</p>

<table>
<thead>
<tr>
<th></th>
<th> assetable_id </th>
<th> assetable_type </th>
<th> type                      </th>
<th> owner_id </th>
<th> owner_type </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 1            </td>
<td> Employee       </td>
<td> Ckeditor::CkeditorPicture </td>
<td> 2        </td>
<td> Product    |</td>
</tr>
</tbody>
</table>


<p>assetable_type => 這個資料的上傳者class</p>

<p>type      => 這張照片是哪個model new進來的</p>

<p>owner_type    => 這張照片被用在哪個class下</p>

<p>看完表格就知道我的scope在幹嘛了～</p>

<pre><code>scope :myupload_orphan, -&gt; (employee_id) {where(assetable_id: employee_id, owner_id: nil)}
scope :by_owner_type, -&gt; (owner,employee_id) {where(owner_type: owner.class.name, owner_id: nil, assetable_id: employee_id)}
scope :by_owner, -&gt; (owner) { where(owner_id: owner.id)}
</code></pre>

<p>完整程式：</p>

<pre><code>class Ckeditor::CkeditorPicture &lt; Ckeditor::Asset
  belongs_to :owner, polymorphic: true
  mount_uploader :data, CkeditorPictureUploader, :mount_on =&gt; :data_file_name

  scope :myupload_orphan, -&gt; (employee_id) {where(assetable_id: employee_id, owner_id: nil)}
  scope :by_owner_type, -&gt; (owner,employee_id) {where(owner_type: owner.class.name, owner_id: nil, assetable_id: employee_id)}
  scope :by_owner, -&gt; (owner) { where(owner_id: owner.id)}

  def url_content
    url(:content)
  end
end
</code></pre>

<h2>Step4. 修改ckeitor 設定</h2>

<p>我是使用coffeescript</p>

<pre><code>$(document).on 'ready page:load', -&gt;
  $('[data-content-editor]').each -&gt;
    $this = $(this)
    CKEDITOR.replace(
      this
      allowedContent: true

  # 設定要處理image處理
      filebrowserImageBrowseUrl: $this.data('upload-url')

      filebrowserImageUploadUrl: $this.data('upload-url')
    )
</code></pre>

<h2>Step5. 修改用到ckeditor的View</h2>

<p>我是使用simple_form</p>

<pre><code>= f.input :content, label: '內容', input_html: { class: 'form-control', data: {content_editor: true, upload_url: upload_url_for(@product)} } 
</code></pre>

<p>upload_url_for請看下面</p>

<h2>Step6. helper</h2>

<p>寫這個helper的原因是因為我希望不同的model都可以使用</p>

<p><strong>app/helpers/cooladmin/admin_helper.rb</strong></p>

<pre><code>module Cooladmin::AdminHelper
  def upload_url_for(resource)
    if resource.new_record?
      cooladmin_ckeditor_pictures_path(:owner_type =&gt; resource.class.name)
    else
      cooladmin_ckeditor_pictures_path(:owner_type =&gt; resource.class.name, :owner_id =&gt; resource.id)
    end
  end
end
</code></pre>

<h2>Step7. Route</h2>

<pre><code>Rails.application.routes.draw do
  # mount Ckeditor::Engine =&gt; '/uradmin/ckeditor'

  resources :ckeditor_pictures, only: [:index, :create, :destroy]

  namespace :cooladmin do
    # ....略
    # ckeditor使用
    resources :ckeditor_pictures, only: [:index, :create, :destroy]
  end

end
</code></pre>

<h2>完成！！！！！！！！！！！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HowTo] - Implement autocomplete feature in elasticsearch using soulmate.js in Ruby on Rails application]]></title>
    <link href="http://ccaloha.cc/blog/2014/12/03/howto-implement-autocomplete-feature-in-elasticsearch-using-soulmate-dot-js-in-ruby-on-rails-application/"/>
    <updated>2014-12-03T07:50:57+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/12/03/howto-implement-autocomplete-feature-in-elasticsearch-using-soulmate-dot-js-in-ruby-on-rails-application</id>
    <content type="html"><![CDATA[<p>先說明一下需求，你希望使用者在搜尋框框打字的時，希望可以給他推薦就像....</p>

<p><img alt="elasticsearch autocomple sample" src="https://dl.dropboxusercontent.com/u/22307926/Blog%20Image/%5BHowTo%5D%20-%20Implement%20autocomplete%20feature%20in%20elasticsearch%20using%20soulmate.js%20in%20Ruby%20on%20Rails%20application/f1.png"></p>

<p>故這篇文章，你可以知道，如何透過elasticsearch 達成 自動化推薦的功能！</p>

<p>以及 如何將此功能與 soulmate.js結合 (因為我之前是用soulmate來實作，但是會推薦的詞，一定是user有打過有搜尋過的字)</p>

<!-- more -->


<h2>Step0. 你可以先玩看看 soulmate.js</h2>

<p><a href="http://josephndungu.com/tutorials/fast-autocomplete-search-terms-rails">FAST AUTOCOMPLETE SEARCH TERMS - RAILS</a></p>

<p>另外這篇主要是參考</p>

<p><a href="https://shellycloud.com/blog/2013/10/adding-search-and-autocomplete-to-a-rails-app-with-elasticsearch">Adding search and autocomplete to a Rails app with Elasticsearch</a></p>

<h2>Step1. Searchkick</h2>

<p>下面加入到 <strong><em>Gemfile</em></strong>:</p>

<pre><code>gem 'searchkick'
</code></pre>

<h2>Step2. Routing</h2>

<p>因為我是要在產品搜尋時做自動推薦，所以在product的routing 加上 autocomplete</p>

<p>下面加入到 <strong><em>config/routes.rb</em></strong></p>

<pre><code>  #下面那行之前沒有elasticsearch幫忙，直接用soulmate實作時的做法
  #mount Soulmate::Server, :at =&gt; "/autocomplete" 

  resources :products do
    collection do
      get :autocomplete
      get :search
    end
  end 
</code></pre>

<h2>Step3. Model</h2>

<p>為了要吐給soulmate json (你可以參考：https://github.com/seatgeek/soulmate#loading-items)</p>

<p>下面加上在<strong><em>app/models/product.rb</em></strong></p>

<pre><code># 讓elasticsearch知道這兩個欄位要做autocomplete功能(他會針對這兩個欄位做不一樣的index)
searchkick autocomplete: ['name', 'description']


# 到時候要吐給soulmate的json格式，你可以參考：https://github.com/seatgeek/soulmate#loading-items)

def to_soulmate
    {
      "term" =&gt; "#{brand.name}-#{name}",
      "id" =&gt; "#{product_id}",
      "score" =&gt; "",
      "data" =&gt; {
        "link" =&gt; "/product_searchs/product?keyword=#{name}"
      }
    }
end
</code></pre>

<p>另外我有create 一個<strong>keyword</strong>的model這邊就不特別說了～controller會用到</p>

<h2>Step4. Controller</h2>

<p>關鍵！</p>

<p>加在 <strong><em>app/controllers/products_controller.rb</em></strong></p>

<pre><code>def autocomplete
    # searchkick做autocomplete
    @products = Product.search params[:term], limit: 10, fields: [{"description" =&gt; :word},{"name" =&gt; :word}]

    # 為了拼出讓soulmate知道的url
    callback_str = params[:callback]
    return_data = {
        "term" =&gt;  "#{params[:term]}", 
        "results" =&gt; {
            "keyword" =&gt;  @products.map(&amp;:to_soulmate)
        }
    }
    # 以下是為了拼出給soulmate的callback
    render json: callback_str + "(" + "#{return_data.to_json}" + ")"
end

def search
    if params[:keyword].present?
        @products = Product.searchkick(params[:keyword],sort,search_page)

        if @products.present?
            @keyword = Keyword.find_or_create_by(name: "#{params[:keyword]}") do |k|
                k.score = 0
                k.url = "/products/search?keyword=#{params[:keyword]}"
                k.keyword_type = "Keyword"
            end
            @keyword.update_attribute(:score, @keyword.score+=1) #代表多搜尋了一次
            # remove_from_soulmate(@keyword) #已用不到
            # load_into_soulmate(@keyword)  #已用不到
        end
    end
end

def load_into_soulmate(keyword)
    loader = Soulmate::Loader.new("#{keyword.keyword_type}")
    loader.add("term" =&gt; keyword.name, "id" =&gt; keyword.id, "score" =&gt; keyword.score, "data" =&gt; { "link" =&gt; "#{keyword.url}"})
end

def remove_from_soulmate(keyword)
    loader = Soulmate::Loader.new("#{keyword.keyword_type}")
  loader.remove("id" =&gt; keyword.id)
end
</code></pre>

<p>這邊很重要的是，你使用soulmate.js去做autocomplete時，他會丟出一串callback給server，基本上你的response也要包含這個callback，我覺得很像jsonp</p>

<p>[注意！] 我把load_into_soulmate還有remove_from_soulmate留著只是單純給你看之前的做法，</p>

<p>但是我還是有保留keyword的model這樣我才知道哪些關鍵字被打了最多次！(當然你可以用GA但是由於隱私權設定，你很多會看到not provided....囧)</p>

<h2>Step5. View</h2>

<p>加上你想要搜尋的頁面，我們希望使用者可以在所有網頁都看到，所以是放在</p>

<p><strong><em>app/views/layouts/application.html.slim</em></strong></p>

<pre><code>= text_field_tag 'keyword', '輸入產品關鍵字', class: "form-control"
= button_tag "搜尋", id: "product_search", class: "btn btn-default"
</code></pre>

<h2>Step6. javascript</h2>

<pre><code># 這是要給product_search點擊後使用
$("#product_search").click(function(){
    window.location = '&lt;%= search_products_path %&gt;?keyword=' + $("#keyword").val();
})

#這是soulmate用法：注意我把url改掉了！
$('#keyword').soulmate({
    url: '/products/autocomplete',
    types: ['product','review','keyword'],
    renderCallback : render,
    selectCallback : select,
    minQueryLength : 1,
    maxResults     : 10,
    timeout:    5000
})
</code></pre>

<h2>完成！！！</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HOWTO] Using ElasticSearch in Ruby on Rails and setup remote ES server via Vagrant]]></title>
    <link href="http://ccaloha.cc/blog/2014/11/27/howto-using-elasticsearch-in-ruby-on-rails-and-setup-remote-es-server-via-vagrant/"/>
    <updated>2014-11-27T07:45:20+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/11/27/howto-using-elasticsearch-in-ruby-on-rails-and-setup-remote-es-server-via-vagrant</id>
    <content type="html"><![CDATA[<p>首先，要先感謝 "老王"，和 "Marz"哥，給我參考他們的Elasticsearch的文件！</p>

<p>安裝部分，就是參考他們的操作！</p>

<p>這邊最主要的不一樣，是設定遠端的Elasticsearch機器！</p>

<p>改天我會補上 如何實作 "搜尋字詞推薦"，而且是整合soulmate歐！！</p>

<!-- more -->


<h2>Mac本機開發</h2>

<h3>安裝 elastic search</h3>

<pre><code>brew install elasticsearch
</code></pre>

<h3>連結</h3>

<pre><code>ln -sfv /usr/local/opt/elasticsearch/*.plist ~/Library/LaunchAgents
</code></pre>

<h3>啟動</h3>

<pre><code>launchctl load ~/Library/LaunchAgents/homebrew.mxcl.elasticsearch.plist
</code></pre>

<h3>關閉</h3>

<pre><code>launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.elasticsearch.plist
</code></pre>

<h3>Run ElasticSearch</h3>

<pre><code>export JAVA_HOME="/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home"
elasticsearch

(或是)

elasticsearch --config=/usr/local/opt/elasticsearch/config/elasticsearch.yml  
</code></pre>

<h3>測試是否安裝成功</h3>

<pre><code>curl -X GET http://localhost:9200
</code></pre>

<p>你應該會看到</p>

<pre><code>{
  "status" : 200,
  "name" : "Rage",
  "version" : {
    "number" : "1.3.2",
    "build_hash" : "dee175dbe2f254f3f26992f5d7591939aaefd12f",
    "build_timestamp" : "2014-08-13T14:29:30Z",
    "build_snapshot" : false,
    "lucene_version" : "4.9"
  },
  "tagline" : "You Know, for Search"
}
</code></pre>

<h3>Code 要加入</h3>

<p>新增一個檔案</p>

<p><strong>lib/tasks/elasticsearch.rake</strong></p>

<p>寫入</p>

<pre><code>require 'elasticsearch/rails/tasks/import'
</code></pre>

<p>修改<strong>Gemfile</strong>，加入</p>

<pre><code>gem 'elasticsearch-rails'
gem 'elasticsearch-model' 
</code></pre>

<h3>跑index</h3>

<p>詳情請參考：<strong>Gem: </strong><a href="https://github.com/elasticsearch/elasticsearch-rails/tree/master/elasticsearch-rails">elasticsearch-rail</a></p>

<pre><code>bundle exec rake environment elasticsearch:import:all
</code></pre>

<p>如果只需要import一個model</p>

<pre><code>bundle exec rake environment elasticsearch:import:model CLASS='Article'
</code></pre>

<p>如果只需要import某些特定的scope</p>

<pre><code>bundle exec rake environment elasticsearch:import:model CLASS='Article' SCOPE='published'
</code></pre>

<h3>清除index</h3>

<pre><code>Article.__elasticsearch__.client.indices.delete index: Article.index_name rescue nil
</code></pre>

<h2>安裝elasticsearch 在Ubuntu 裡面</h2>

<h3>使用vagrant 起三檯機器(用來模擬正式環境)</h3>

<p>請查看前半部</p>

<p><a href="http://ccaloha.cc/blog/2014/09/19/howto-using-sunspot-access-remote-solr-instance-ubuntu-14-dot-04-in-ruby-on-rails-using-vagrant/">HOWTO - Using Sunspot to Access Remote Solr instance(Ubuntu 14.04) in Ruby on Rails Using Vagrant</a></p>

<h3>安裝 elascticsearch</h3>

<pre><code>vagrant ssh search 
sudo apt-get install openjdk-7-jre-headless -y
sudo wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -
</code></pre>

<h3>編輯source list</h3>

<pre><code>sudo vim /etc/apt/sources.list
</code></pre>

<p>把下面的code放進去</p>

<pre><code>  deb http://packages.elasticsearch.org/elasticsearch/1.3/debian stable main
</code></pre>

<p>繼續安裝</p>

<pre><code>  sudo apt-get update
  sudo apt-get install elasticsearch
  sudo update-rc.d elasticsearch defaults 95 10
  sudo /etc/init.d/elasticsearch start
</code></pre>

<h2>Ruby on Rails 部分</h2>

<h3>更改producion deploy的東東</h3>

<p><strong>config/deploy/production.rb</strong></p>

<pre><code>  role :app, %w{apps@33.33.13.10}
  role :web, %w{apps@33.33.13.10}
  role :db,  %w{apps@33.33.13.11}
  role :crontaber, %w{apps@33.33.13.10}
  set :rails_env, :production
  set :unicorn_rack_env, :production
  set :branch, 'feature/update_search_engine_to_elasticsearch'
</code></pre>

<p>我故意把ip改成 vagrant的ip</p>

<p>另外，branch也用成我自己測試的branch: <strong>feature/update_search_engine_to_elasticsearch</strong></p>

<h2>如何設定將elasticsearch 連到別台機器</h2>

<ol>
<li><p>新增一個 <strong>config/elasticsearch.yml</strong></p>

<pre><code> default: &amp;default
   host: 127.0.0.1:9200

 development:
   &lt;&lt;: *default
   host: 127.0.0.1:9200

 test:
   &lt;&lt;: *default

 production:
   &lt;&lt;: *default
   host: 33.33.13.12:9200
</code></pre></li>
<li><p>在application.rb加入</p>

<pre><code> es = YAML.load(File.open("#{Rails.root}/config/elasticsearch.yml"))[Rails.env]

   elasticsearch_config = {
       host: es["host"],
       transport_options: {
       request: { timeout: 5 }
       },
   }
   Elasticsearch::Model.client = Elasticsearch::Client.new(elasticsearch_config)
</code></pre></li>
<li><p>因為我的product需要做搜尋，所以在Product model 我這樣寫</p></li>
</ol>


<p>  (ps. elasticsearch 真的是博大精深，我沒有時間去深入專研，以下的指令是我try出最符合我需要的搜尋結果，所以大家可參考參考)</p>

<pre><code>def self.essearch(query,sort,page)
  if sort == 'relevance'

    results = __elasticsearch__.search(
      {
        query: {
          filtered: {
            filter: {
              range: { product_price_min: { "gt" =&gt; 0} }
             }, 
            query: {
              bool: {
                must: [
                  multi_match: {
                    query: query,
                    type:  "phrase",
                    fields: ["product_cname^10", "product_ename^10",'product_description', 'product_keyword']
                  }
                ]
              }
            }
          }
        },
        "sort" =&gt; [
          "_score",
          {"product_urcosme_exp" =&gt; {"order" =&gt; "desc"} } 
        ],
        "from" =&gt; (page.to_i-1)*5,
        "size" =&gt; 5          
      }
    )
  else
    # 因為不是精準搜尋，所以這邊的排序就真的會依照我們給他的sort，
    # 但是你總不希望，搜尋面膜，結果第一個結果是：淨膚儀，就因為他的上市時間最晚....囧～
    # 所以，我還是希望第一個看到的結果是以關鍵字有出現的為佳，所以我多使用了filter的功能
    results = __elasticsearch__.search(
      {
        query: {
          filtered: {
            filter: {
              range: { product_price_min: { "gt" =&gt; 0} }
             },
            filter: {
               exists: { field: "product_keyword" }
             },
            query: {
              bool: {
                must: [
                  multi_match: {
                    query: query,
                    type:  "cross_fields",
                    fields: ['product_cname', 'product_ename'],
                    operator:   "and", 
                    #minimum_should_match: '30%'
                  }
                ],
                should: [
                  { match: { "product_description" =&gt;  query}},
                  { match: { "product_keyword" =&gt; query }}
                ],
              }
            }
          }
        },
        "sort" =&gt; [
          {"#{sort}" =&gt; {"order" =&gt; "#{sort == "product_price_min"? 'asc' : 'desc'}"} } , 
           "_score",
          { "product_cname" =&gt; "desc" }
        ],
        "from" =&gt; (page.to_i-1)*5,
        "size" =&gt; 5        
      }
    )
  # 這邊目的是為了如果上面都沒有搜尋結果才做的比較rough的搜尋
  if results.results.size == 0
    results = __elasticsearch__.search(
      {
        query: {
          filtered: {
            filter: {
              range: { product_price_min: { "gt" =&gt; 0} }
             },
            query: {
              bool: {
                must: [
                  multi_match: {
                    query: query,
                    type:  "cross_fields",
                    fields: ['product_cname', 'product_ename','product_description','product_keyword'],
                    operator:   "and"
                  }
                ]
              }
            }
          }
        },
        "sort" =&gt; [
          {"#{sort}" =&gt; {"order" =&gt; "#{sort == "product_price_min"? 'asc' : 'desc'}"} } , 
           "_score",
          { "product_cname" =&gt; "desc" }
        ],
        "from" =&gt; (page.to_i-1)*5,
        "size" =&gt; 5          
      }
    )
  end
  end
  return results
end
</code></pre>

<ol>
<li><p>在product的controller</p>

<p>   @products = Product.essearch(params[:keyword],params[:sort],params[:page])</p>

<p>   @products =  search.results.results</p>

<p> 接下來就是丟給view顯示了～我就不提了～</p></li>
</ol>


<h3>接下來就是deploy加上看看有沒有成功摟</h3>

<pre><code>cap production deploy #因為"config/deploy/production.rb"有改成vagrant設定，所以請放心～
vagrant ssh search    # 登入你的搜尋機器
elasticsearch         # 把elasticsearch 服務跑起來
vagrant ssh app       # 登入跑服務的機器
cd 你的專案            
bundle exec rake environment elasticsearch:import:all  #跑index，這邊如果有成功，代表你已經連過去遠端了！
</code></pre>

<h3>完成！</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HOWTO] Using Sunspot to access remote Solr instance(Ubuntu 14.04) in Ruby on Rails using Vagrant]]></title>
    <link href="http://ccaloha.cc/blog/2014/09/19/howto-using-sunspot-access-remote-solr-instance-ubuntu-14-dot-04-in-ruby-on-rails-using-vagrant/"/>
    <updated>2014-09-19T20:16:23+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/09/19/howto-using-sunspot-access-remote-solr-instance-ubuntu-14-dot-04-in-ruby-on-rails-using-vagrant</id>
    <content type="html"><![CDATA[<p> 首先，當然要感謝網路上一堆大神的資源</p>

<p> 特別是：</p>

<p> <a href="https://gorails.com/setup/ubuntu/14.04">Setup Ruby On Rails on
Ubuntu 14.04 Trusty Tahr</a></p>

<p><a href="https://gorails.com/deploy/ubuntu/14.04">Deploy Ruby On Rails on
Ubuntu 14.04 Trusty Tahr</a></p>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-solr-on-ubuntu-14-04">How to Install Solr on Ubuntu 14.04</a></p>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-redis">How To Install and Use Redis</a></p>

<p><a href="http://gogojimmy.net/2013/05/26/vagrant-tutorial/">[教學]使用Vagrant練習環境佈署</a></p>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-memcache-on-ubuntu-14-04">How To Install and Use Memcache on Ubuntu 14.04</a></p>

<p>一開始之前，來說一下，我的目標：</p>

<p>起一台 WEB server 和 Solr server(search engine)，Database則是使用 Mac裡面的 mysql(因為我開發時把DB資料都建在那邊了)，讓這三方彼此co work !</p>

<h2>心得分享</h2>

<blockquote><p>其實本機端的Sunspot他其實也是透過把指令丟給localhost:8983的搜尋引擎做搜尋，現在只是要把丟到localhost:8983換成另外一個遠端的IP。所以，對於Sunspot來說，就是改個config檔。至於做Index的話，我本來以為要讓遠端的搜尋引擎可以access到DB，然後登入到搜尋引擎的機器去設定？。但....根本就不用，一樣，Sunspot已經幫你做掉了，所以基本上，只要你的Rail專案設定的database.yml可以access，Sunspot會自動幫你對應 DB和 遠端的搜尋引擎做index，所以沒有想像中的困難！</p></blockquote>

<p>了解大概流程概念後，那就來實作吧</p>

<h2>使用Vagrant，模擬多機器的環境</h2>

<p>當然要起很多機器，當然是要使用  <strong><a href="https://www.vagrantup.com/">Vagrant</a> + <a href="https://www.virtualbox.org/">VirtualBox</a></strong></p>

<p>那Vagrant的部分，步驟說明就交給Jimmy大大了 <a href="http://gogojimmy.net/2013/05/26/vagrant-tutorial/">[教學]使用Vagrant練習環境佈署</a>！</p>

<p>和Jimmy大大，不一樣的地方大概就是一些有部分調整的lib和script</p>

<p>這邊直接打我的操作流程：</p>

<ol>
<li>下載Vagrant，<a href="http://www.vagrantup.com/downloads">點我到官網下載連結</a></li>
<li>下載Virtual Box，<a href="https://www.virtualbox.org/wiki/Downloads">點我到官網下載</a></li>
<li><p>抓image</p>

<pre><code> vagrant box add Ubuntu-14-04-64bit https://cloud-images.ubuntu.com/vagrant/trusty/current/trusty-server-cloudimg-amd64-vagrant-disk1.box
</code></pre></li>
<li><p>初始化</p>

<pre><code> vagrant init Ubuntu-14-04-64bit
</code></pre></li>
<li><p>把機器Run起來</p>

<pre><code>vagrant up 
</code></pre></li>
<li><p>登入機器</p>

<pre><code>vagrant ssh 
</code></pre></li>
<li><p>安裝Ruby 環境(這邊我有小修一點東西，讓指令跑起來ok)</p>

<pre><code> curl -L https://gist.githubusercontent.com/alChaCC/f1295f5024eb4de71008/raw/bee55fd048b274b40095c6e645aa5ca38721fcc2/bootstrap-chef-solo.sh | sh
</code></pre></li>
<li><p>登出 機器</p>

<pre><code>exit    
</code></pre></li>
<li><p>打包這個Box</p>

<pre><code> vagrant package
</code></pre></li>
<li><p>開一個mobile的box</p>

<pre><code> vagrant box add ubuntu-14_04 package.box
</code></pre></li>
<li><p>設定Vagrantfile 讓你可一次起N檯機器(2014/9/17這是目前最新的設定)</p>

<pre><code> vim Vagrantfile
</code></pre></li>
</ol>


<p>加入：</p>

<pre><code>config.vm.define :app do |app_config|
      app_config.vm.provider :virtualbox do |vb|
        vb.customize ["modifyvm", :id, "--name", "app", "--memory", "1024"]
      end
      app_config.vm.box = "Ubuntu-14-04-64bit"
      app_config.vm.host_name = "app"
      app_config.vm.network "private_network", ip: "33.33.13.10"
  end

  config.vm.define :search do |search_config|
    search_config.vm.provider :virtualbox do |vb|
        vb.customize ["modifyvm", :id, "--name", "search", "--memory", "1024"]
    end
    search_config.vm.box = "Ubuntu-14-04-64bit"
    search_config.vm.host_name = "search"
    search_config.vm.network "private_network", ip: "33.33.13.12"
  end
</code></pre>

<h2>安裝機器.....using Chef ....But</h2>

<p>照理說這邊應該跟得上時代，使用 chef_solo, knife 來安裝才是....</p>

<p>但...由於時間的關係，實在沒時間玩，你懂得～專案還是要Go啊～ 何況是，我必須在兩天之內試出東西</p>

<p>Anyway, 傻人只好用傻方法</p>

<h2>安裝 Rails 環境 在app機器上</h2>

<p>Ruby 2.1.2  + rvm</p>

<ol>
<li><p>登入</p>

<pre><code> vagrant ssh app
</code></pre></li>
<li><p>加上 user</p>

<pre><code> sudo adduser deploy
 sudo adduser deploy sudo
 su deploy
</code></pre></li>
<li></li>
<li><p>安裝基本lib</p>

<pre><code> sudo apt-get update
 sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties
</code></pre></li>
<li><p>安裝rvm</p>

<pre><code> sudo apt-get install libgdbm-dev libncurses5-dev automake libtool bison libffi-dev
 curl -L https://get.rvm.io | bash -s stable
 source ~/.rvm/scripts/rvm
 echo "source ~/.rvm/scripts/rvm" &gt;&gt; ~/.bashrc
 rvm install 2.1.2
 rvm use 2.1.2 --default
 ruby -v
 echo "gem: --no-ri --no-rdoc" &gt; ~/.gemrc
</code></pre></li>
<li><p>安裝Rails</p>

<pre><code> sudo add-apt-repository ppa:chris-lea/node.js
 sudo apt-get update
 sudo apt-get install nodejs
 gem install rails
</code></pre></li>
<li><p>安裝  nginx + Passenger</p>

<pre><code> sudo apt-get install apt-transport-https
 sudo sh -c "echo 'deb https://oss-binaries.phusionpassenger.com/apt/passenger trusty main' &gt;&gt; /etc/apt/sources.list.d/passenger.list"
 sudo chown root: /etc/apt/sources.list.d/passenger.list
 sudo chmod 600 /etc/apt/sources.list.d/passenger.list
 sudo apt-get update
 sudo apt-get install nginx-full passenger
</code></pre></li>
<li><p>修改 nginx 檔案</p>

<pre><code> sudo vim /etc/nginx/nginx.conf
</code></pre>

<p> 加上</p>

<pre><code> passenger_root /usr/lib/ruby/vendor_ruby/phusion_passenger/locations.ini;
 passenger_ruby /home/deploy/.rvm/wrappers/ruby-2.1.2/ruby;
</code></pre></li>
<li><p>修改 Nginx Host</p>

<pre><code> sudo vim /etc/nginx/sites-enabled/default
</code></pre>

<p> 改上</p>

<pre><code> server {
 listen 80 default_server;
 listen [::]:80 default_server ipv6only=on;

 root /home/deploy/我的資料夾名稱/current/public;
 # index index.html index.htm;
 rails_env production;
 passenger_enabled on;
 # Make site accessible from http://localhost/
 server_name 33.33.13.10; # 這邊我讓他跟vagrant機器ip一樣

 error_page   500 502 503 504  /50x.html;
 location = /50x.html {
     root   html;
 }
</code></pre></li>
<li><p>安裝Redis</p>

<pre><code> sudo apt-get install tcl8.5
 wget http://download.redis.io/releases/redis-2.8.9.tar.gz
 tar xzf redis-2.8.9.tar.gz
 cd redis-2.8.9
 make
 make test
 sudo make install
 cd utils
 sudo ./install_server.sh
</code></pre></li>
<li><p>Install memcached</p>

<pre><code> sudo apt-get install mysql-server php5-mysql php5 php5-memcached memcached
 sudo service memcached start
</code></pre></li>
<li><p>安裝mysql</p>

<pre><code>sudo apt-get install mysql-server mysql-client libmysqlclient-dev
</code></pre></li>
</ol>


<h2>安裝 Solr 環境 在search機器上</h2>

<p>我使用tomcat 安裝會有問題(<strong>missing core name in path</strong>)....所以我最後手動安裝</p>

<ol>
<li><p>安裝 java</p>

<pre><code> sudo apt-get -y install openjdk-7-jdk
 mkdir /usr/java
 ln -s /usr/lib/jvm/java-7-openjdk-amd64 /usr/java/default
</code></pre></li>
<li><p>安裝Solr</p>

<pre><code> cd /opt
 wget http://archive.apache.org/dist/lucene/solr/4.7.2/solr-4.7.2.tgz
 tar -xvf solr-4.7.2.tgz
 cp -R solr-4.7.2/example /opt/solr
 cd /opt/solr
 java -jar start.jar
</code></pre></li>
<li><p>編輯 jetty</p>

<pre><code> sudo vim /etc/default/jetty 
</code></pre>

<p> 加入</p>

<pre><code> NO_START=0 # Start on boot
 JAVA_OPTIONS="-Dsolr.solr.home=/opt/solr/solr $JAVA_OPTIONS"
 JAVA_HOME=/usr/java/default
 JETTY_HOME=/opt/solr
 JETTY_USER=solr
 JETTY_LOGS=/opt/solr/logs
</code></pre>

<p> 下指令</p>

<pre><code> vim /opt/solr/etc/jetty-logging.xml
</code></pre>

<p> 加入</p>

<pre><code> &lt;?xml version="1.0"?&gt;
   &lt;!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN" "http://jetty.mortbay.org/configure.dtd"&gt;
   &lt;!-- =============================================================== --&gt;
   &lt;!-- Configure stderr and stdout to a Jetty rollover log file --&gt;
   &lt;!-- this configuration file should be used in combination with --&gt;
   &lt;!-- other configuration files.  e.g. --&gt;
   &lt;!--    java -jar start.jar etc/jetty-logging.xml etc/jetty.xml --&gt;
   &lt;!-- =============================================================== --&gt;
   &lt;Configure id="Server" class="org.mortbay.jetty.Server"&gt;

       &lt;New id="ServerLog" class="java.io.PrintStream"&gt;
         &lt;Arg&gt;
           &lt;New class="org.mortbay.util.RolloverFileOutputStream"&gt;
             &lt;Arg&gt;&lt;SystemProperty name="jetty.logs" default="."/&gt;/yyyy_mm_dd.stderrout.log&lt;/Arg&gt;
             &lt;Arg type="boolean"&gt;false&lt;/Arg&gt;
             &lt;Arg type="int"&gt;90&lt;/Arg&gt;
             &lt;Arg&gt;&lt;Call class="java.util.TimeZone" name="getTimeZone"&gt;&lt;Arg&gt;GMT&lt;/Arg&gt;&lt;/Call&gt;&lt;/Arg&gt;
             &lt;Get id="ServerLogName" name="datedFilename"/&gt;
           &lt;/New&gt;
         &lt;/Arg&gt;
       &lt;/New&gt;

       &lt;Call class="org.mortbay.log.Log" name="info"&gt;&lt;Arg&gt;Redirecting stderr/stdout to &lt;Ref id="ServerLogName"/&gt;&lt;/Arg&gt;&lt;/Call&gt;
       &lt;Call class="java.lang.System" name="setErr"&gt;&lt;Arg&gt;&lt;Ref id="ServerLog"/&gt;&lt;/Arg&gt;&lt;/Call&gt;
       &lt;Call class="java.lang.System" name="setOut"&gt;&lt;Arg&gt;&lt;Ref id="ServerLog"/&gt;&lt;/Arg&gt;&lt;/Call&gt;&lt;/Configure&gt;
</code></pre></li>
<li><p>加上 User: solr</p>

<pre><code> sudo useradd -d /opt/solr -s /sbin/false solr
 sudo chown solr:solr -R /opt/solr
</code></pre></li>
<li><p>安裝 jetty</p>

<pre><code> sudo wget -O /etc/init.d/jetty http://dev.eclipse.org/svnroot/rt/org.eclipse.jetty/jetty/trunk/jetty-distribution/src/main/resources/bin/jetty.sh
 sudo chmod a+x /etc/init.d/jetty
 sudo update-rc.d jetty defaults
</code></pre></li>
<li><p>跑起來</p>

<pre><code> sudo /etc/init.d/jetty start
</code></pre></li>
<li><p>設定檔</p>

<pre><code> cd /opt/solr/solr
</code></pre></li>
<li><p>把在sunspot改好的schema.xml 寫到這邊</p>

<pre><code> vim /opt/solr/solr/collection1/conf/schema.xml
</code></pre>

<p> 寫上下面那些，因為我要支援中文字詞，所以我有改過一些</p>

<p> 下面這個很重要，如果不改的話，會有連線內容錯誤之類的訊息</p>

<pre><code> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 --&gt;
 &lt;!--  
  This is the Solr schema file. This file should be named "schema.xml" and
  should be in the conf directory under the solr home
  (i.e. ./solr/conf/schema.xml by default) 
  or located where the classloader for the Solr webapp can find it.

  This example schema is the recommended starting point for users.
  It should be kept correct and concise, usable out-of-the-box.

  For more information, on how to customize this file, please see
  http://wiki.apache.org/solr/SchemaXml

  PERFORMANCE NOTE: this schema includes many optional features and should not
  be used for benchmarking.  To improve performance one could
   - set stored="false" for all fields possible (esp large fields) when you
     only need to search on the field but don't need to return the original
     value.
   - set indexed="false" if you don't need to search on the field, but only
     return the field as a result of searching on other indexed fields.
   - remove all unneeded copyField statements
   - for best index size and searching performance, set "index" to false
     for all general text fields, use copyField to copy them to the
     catchall "text" field, and use that for searching.
   - For maximum indexing performance, use the StreamingUpdateSolrServer
     java client.
   - Remember to run the JVM in server mode, and use a higher logging level
     that avoids logging every request
 --&gt;
 &lt;schema name="sunspot" version="1.0"&gt;
   &lt;types&gt;
     &lt;!-- field type definitions. The "name" attribute is
        just a label to be used by field definitions.  The "class"
        attribute and any other attributes determine the real
        behavior of the fieldType.
          Class names starting with "solr" refer to java classes in the
        org.apache.solr.analysis package.
     --&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="string" class="solr.StrField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="tdouble" class="solr.TrieDoubleField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="rand" class="solr.RandomSortField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="text" class="solr.TextField" omitNorms="false"&gt;
       &lt;analyzer&gt;
         &lt;tokenizer class="solr.CJKTokenizerFactory"/&gt;
         &lt;filter class="solr.StandardFilterFactory"/&gt;
         &lt;filter class="solr.LowerCaseFilterFactory"/&gt;
         &lt;filter class="solr.PorterStemFilterFactory"/&gt;
         &lt;filter class="solr.NGramFilterFactory" minGramSize="2" maxGramSize="15"/&gt;
       &lt;/analyzer&gt;

       &lt;analyzer type="query"&gt;
         &lt;tokenizer class="solr.CJKTokenizerFactory"/&gt;
         &lt;filter class="solr.StandardFilterFactory"/&gt;
         &lt;filter class="solr.LowerCaseFilterFactory"/&gt;
       &lt;/analyzer&gt;

     &lt;/fieldType&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="boolean" class="solr.BoolField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="date" class="solr.DateField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="sdouble" class="solr.SortableDoubleField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="sfloat" class="solr.SortableFloatField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="sint" class="solr.SortableIntField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="slong" class="solr.SortableLongField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="tint" class="solr.TrieIntField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="tfloat" class="solr.TrieFloatField" omitNorms="true"/&gt;
     &lt;!-- *** This fieldType is used by Sunspot! *** --&gt;
     &lt;fieldType name="tdate" class="solr.TrieDateField" omitNorms="true"/&gt;

     &lt;!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. --&gt;
     &lt;fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/&gt;
   &lt;/types&gt;
   &lt;fields&gt;
     &lt;!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a previously defined type from the
        &lt;types&gt; section
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      compressed: [false] if this field should be stored using gzip compression
        (this will only apply if the field type is compressable; among
        the standard field types, only TextField and StrField are)
      multiValued: true if this field may contain multiple values per document
      omitNorms: (expert) set to true to omit the norms associated with
        this field (this disables length normalization and index-time
        boosting for the field, and saves some memory).  Only full-text
        fields or fields that need an index-time boost need norms.
      termVectors: [false] set to true to store the term vector for a
        given field.
        When using MoreLikeThis, fields used for similarity should be
        stored for best performance.
      termPositions: Store position information with the term vector.  
        This will increase storage costs.
      termOffsets: Store offset information with the term vector. This 
        will increase storage costs.
      default: a value that should be used if no value is specified
        when adding a document.
    --&gt;
     &lt;!-- *** This field is used by Sunspot! *** --&gt;
     &lt;field name="id" stored="true" type="string" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This field is used by Sunspot! *** --&gt;
     &lt;field name="type" stored="false" type="string" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This field is used by Sunspot! *** --&gt;
     &lt;field name="class_name" stored="false" type="string" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This field is used by Sunspot! *** --&gt;
     &lt;field name="text" stored="false" type="string" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This field is used by Sunspot! *** --&gt;
     &lt;field name="lat" stored="true" type="tdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This field is used by Sunspot! *** --&gt;
     &lt;field name="lng" stored="true" type="tdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="random_*" stored="false" type="rand" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="_local*" stored="false" type="tdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_text" stored="false" type="text" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_texts" stored="true" type="text" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_b" stored="false" type="boolean" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_bm" stored="false" type="boolean" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_bs" stored="true" type="boolean" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_bms" stored="true" type="boolean" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_d" stored="false" type="date" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_dm" stored="false" type="date" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ds" stored="true" type="date" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_dms" stored="true" type="date" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_e" stored="false" type="sdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_em" stored="false" type="sdouble" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_es" stored="true" type="sdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ems" stored="true" type="sdouble" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_f" stored="false" type="sfloat" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_fm" stored="false" type="sfloat" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_fs" stored="true" type="sfloat" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_fms" stored="true" type="sfloat" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_i" stored="false" type="sint" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_im" stored="false" type="sint" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_is" stored="true" type="sint" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ims" stored="true" type="sint" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_l" stored="false" type="slong" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_lm" stored="false" type="slong" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ls" stored="true" type="slong" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_lms" stored="true" type="slong" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_s" stored="false" type="string" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_sm" stored="false" type="string" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ss" stored="true" type="string" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_sms" stored="true" type="string" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_it" stored="false" type="tint" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_itm" stored="false" type="tint" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_its" stored="true" type="tint" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_itms" stored="true" type="tint" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ft" stored="false" type="tfloat" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ftm" stored="false" type="tfloat" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_fts" stored="true" type="tfloat" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ftms" stored="true" type="tfloat" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_dt" stored="false" type="tdate" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_dtm" stored="false" type="tdate" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_dts" stored="true" type="tdate" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_dtms" stored="true" type="tdate" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_textv" stored="false" termVectors="true" type="text" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_textsv" stored="true" termVectors="true" type="text" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_et" stored="false" termVectors="true" type="tdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_etm" stored="false" termVectors="true" type="tdouble" multiValued="true" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_ets" stored="true" termVectors="true" type="tdouble" multiValued="false" indexed="true"/&gt;
     &lt;!-- *** This dynamicField is used by Sunspot! *** --&gt;
     &lt;dynamicField name="*_etms" stored="true" termVectors="true" type="tdouble" multiValued="true" indexed="true"/&gt;

     &lt;!-- Type used to index the lat and lon components for the "location" FieldType --&gt;
     &lt;dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false" multiValued="false"/&gt;
     &lt;dynamicField name="*_p" type="location" indexed="true" stored="true" multiValued="false"/&gt;

     &lt;dynamicField name="*_ll" stored="false" type="location" multiValued="false" indexed="true"/&gt;
     &lt;dynamicField name="*_llm" stored="false" type="location" multiValued="true" indexed="true"/&gt;
     &lt;dynamicField name="*_lls" stored="true" type="location" multiValued="false" indexed="true"/&gt;
     &lt;dynamicField name="*_llms" stored="true" type="location" multiValued="true" indexed="true"/&gt;

     &lt;!-- required by Solr 4 --&gt;
     &lt;field name="_version_" type="string" indexed="true" stored="true" multiValued="false" /&gt;
   &lt;/fields&gt;

   &lt;!-- Field to use to determine and enforce document uniqueness.
       Unless this field is marked with required="false", it will be a required field
    --&gt;
   &lt;uniqueKey&gt;id&lt;/uniqueKey&gt;
   &lt;!-- field for the QueryParser to use when an explicit fieldname is absent --&gt;
   &lt;defaultSearchField&gt;text&lt;/defaultSearchField&gt;
   &lt;!-- SolrQueryParser configuration: defaultOperator="AND|OR" --&gt;
   &lt;solrQueryParser defaultOperator="AND"/&gt;
   &lt;!-- copyField commands copy one field to another at the time a document
         is added to the index.  It's used either to index the same field differently,
         or to add multiple fields to the same field for easier/faster searching.  --&gt;
 &lt;/schema&gt;
</code></pre></li>
<li><p>改好別忘重啟</p>

<pre><code> sudo /etc/init.d/jetty restart
</code></pre></li>
<li><p>但是....目前不是用Chef安裝環境....所以如果要改config檔，就是要到這個地方去修改</p>

<p><strong>/opt/solr/solr/collection1/conf</strong></p></li>
</ol>


<h2>專案上的程式碼</h2>

<ol>
<li>基本上，專案什麼都不用動，因為Sunspot都幫你做掉了</li>
</ol>


<p>你只需要改 <strong>config/sunspot.yml</strong></p>

<p>原先的設定：</p>

<pre><code>production:
  solr:
    hostname: localhost
    port: 8983
    log_level: INFO
    path: /solr/production
    # read_timeout: 2
    # open_timeout: 0.5

development:
  solr:
    hostname: localhost
    port: 8982
    log_level: INFO
    path: /solr/development


test:
  solr:
    hostname: localhost
    port: 8981
    log_level: WARNING
    path: /solr/test
</code></pre>

<p> 把它改成：</p>

<pre><code> production:
  solr:
    hostname: 33.33.13.12
    port: 8983
    log_level: INFO
    path: /solr
    # read_timeout: 2
    # open_timeout: 0.5

development:
  solr:
    hostname: localhost
    port: 8982
    log_level: INFO
    path: /solr/development


test:
  solr:
    hostname: localhost
    port: 8981
    log_level: WARNING
    path: /solr/test
</code></pre>

<p>恭喜完成！</p>

<h2>Capistrano Deployment</h2>

<p>如果你參考我的 Sunspot本機端 Deploy的話，</p>

<p>我試過幾種方法，試著讓app機器，可以去search機器 開關solr....(</p>

<pre><code>sudo /etc/init.d/jetty start
</code></pre>

<p>但是小弟對於Capistrano才疏學淺，實在無法達成</p>

<p>所以我的Deploy Code就先把 solr:start 和 solr:stop 先拿掉</p>

<p>所以原先，我是這樣寫的</p>

<p><strong>/lib/capistrano/taks/sunspot.cap</strong></p>

<pre><code>namespace :deploy do
  before :updated, :setup_solr_data_dir do
    on roles(:app) do
      unless test "[ -d #{shared_path}/solr/data ]"
        execute :mkdir, "-p #{shared_path}/solr/data"
      end
    end
  end
end

namespace :solr do

  %w[start stop].each do |command|
    desc "#{command} solr"
    task command do
      on roles(:app) do
        solr_pid = "#{shared_path}/pids/sunspot-solr.pid"
        if command == "start" or (test "[ -f #{solr_pid} ]" and test "kill -0 $( cat #{solr_pid} )")
          within current_path do
            with rails_env: fetch(:rails_env, 'production') do
              execute :bundle, 'exec', 'sunspot-solr', command, "--port=8983 --data-directory=#{shared_path}/solr/data --pid-dir=#{shared_path}/pids --solr-home=#{release_path}/solr"
            end
          end
        end
      end
    end
  end

  desc "reindex solr"
  task :restart do
    invoke 'solr:reindex'
  end

  after 'deploy:finished', 'solr:restart'

  desc "reindex the whole solr database"

  task :reindex do
    invoke 'solr:stop' 
    on roles(:app) do
      execute :rm, "-rf #{shared_path}/solr/data"
    end
    invoke 'solr:start'
    sleep 10
    on roles(:app) do
      within current_path do
        with rails_env: fetch(:rails_env, 'production') do
          info "Reindexing Solr database"
          execute :bundle, 'exec', :rake, 'sunspot:solr:reindex[,,true]'
        end
      end
    end
  end

end
</code></pre>

<p>現在變成：</p>

<pre><code>namespace :deploy do
  before :updated, :setup_solr_data_dir do
    on roles(:app) do
      unless test "[ -d #{shared_path}/solr/data ]"
        execute :mkdir, "-p #{shared_path}/solr/data"
      end
    end
  end
end

namespace :solr do

  %w[start stop].each do |command|
    desc "#{command} solr"
    task command do
      on roles(:app) do
        solr_pid = "#{shared_path}/pids/sunspot-solr.pid"
        if command == "start" or (test "[ -f #{solr_pid} ]" and test "kill -0 $( cat #{solr_pid} )")
          within current_path do
            with rails_env: fetch(:rails_env, 'production') do
              execute :bundle, 'exec', 'sunspot-solr', command, "--port=8983 --data-directory=#{shared_path}/solr/data --pid-dir=#{shared_path}/pids --solr-home=#{release_path}/solr" # 就算加上 --bind-address=33.33.13.12  也在在本機端跑
            end
          end
        end
      end

      #  嘗試直接從本機去重開 search機器，但是都不work，找解答ing
      #on %w{apps@33.33.13.12} do |host|
      #    as 'apps' do
      #      execute "sudo /etc/init.d/jetty #{command}"
      #    end
      #end
    end
  end

  desc "reindex solr"
  task :restart do
    invoke 'solr:reindex'
  end

  after 'deploy:finished', 'solr:restart'

  desc "reindex the whole solr database"

  task :reindex do
    #invoke 'solr:stop' #這指令是操控本機的solr
    on roles(:app) do
      execute :rm, "-rf #{shared_path}/solr/data"
    end
    #invoke 'solr:start' #這指令是操控本機的solr
    sleep 10
    on roles(:app) do
      within current_path do
        with rails_env: fetch(:rails_env, 'production') do
          info "Reindexing Solr database"
          execute :bundle, 'exec', :rake, 'sunspot:solr:reindex[,,true]'
        end
      end
    end
  end

end
</code></pre>

<h2>恭喜完成！</h2>

<h3>ps. 如果你想要讓在vagrant裡頭app可以存取Mac裡頭的DB</h3>

<p>請把把 host改成 10.0.2.2</p>

<pre><code>host: 10.0.2.2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[HOWTO] Using Sunspot(Solr) in Rails including easy suggestion feature and deployment to production environment - Part1]]></title>
    <link href="http://ccaloha.cc/blog/2014/09/06/using-sunspot-in-rails-including-suggestion-feature-and-deployment-to-production-machine-part1/"/>
    <updated>2014-09-06T00:06:35+08:00</updated>
    <id>http://ccaloha.cc/blog/2014/09/06/using-sunspot-in-rails-including-suggestion-feature-and-deployment-to-production-machine-part1</id>
    <content type="html"><![CDATA[<p>這系列文章，你可以學到：</p>

<pre><code>1. 如何使用sunspot，作為你的全站全文搜尋
2. 如何使用work around的方式達成sunspot搜尋的推薦字詞 - 利用solmate
3. 如何將sunspot deploy到production 機器，並且自動做index
4. 簡單調整sunspot
</code></pre>

<!-- more -->


<p>首先，當然是要感謝這些文章：</p>

<ol>
<li><p>Jimmy 高手：  <a href="http://gogojimmy.net/2012/01/25/full-text-search-in-rails-with-solr">在 Rails 中使用 Solr 做全文搜尋</a></p></li>
<li><p><a href="http://josephndungu.com/tutorials/fast-autocomplete-search-terms-rails">FAST AUTOCOMPLETE SEARCH TERMS - RAILS</a></p></li>
<li><p><a href="https://gist.github.com/cec/5508303">Capistrano Tasks to setup and interact with SolR and SunSpot</a></p></li>
</ol>


<h1>Part 1. 如何使用sunspot，作為你的全站全文搜尋</h1>

<h2>Step1. 使用gem</h2>

<p>[手做] 修改 <strong>Gemfile</strong></p>

<pre><code>gem 'sunspot_rails'
gem 'sunspot_solr'
</code></pre>

<p>做完後，別忘了</p>

<pre><code>bundle install
</code></pre>

<h2>Step2. 建立sunspot 設定檔</h2>

<pre><code>rails generate sunspot_rails:install
</code></pre>

<p>他會幫你建立 <strong>config/sunspot.yml</strong></p>

<pre><code>production:
 solr:
   hostname: localhost
   port: 8983
   log_level: WARNING
   path: /solr/production
   # read_timeout: 2
   # open_timeout: 0.5

development:
 solr:
   hostname: localhost
   port: 8982
   log_level: INFO
   path: /solr/development

test:
 solr:
   hostname: localhost
   port: 8981
   log_level: WARNING
   path: /solr/test
</code></pre>

<h2>Step3. 在model 建立搜尋功能</h2>

<p>假設我們現在有個 產品的model叫做： <strong>Product</strong> ，我們希望它的產品名稱、描述、價錢、建立時間、是否上架列為我們要搜尋的項目(也是要建index的部分)</p>

<p>所以我們需要在model加上</p>

<pre><code>searchable do
    ....
end
</code></pre>

<p>就像：<strong>app/models/product.rb</strong></p>

<pre><code># == Schema Information
#
# Table name: products
#
#  id                 :integer          not null, primary key
#  name               :string(20)
#  description        :text             not null
#  price              :integer
#  is_on_the_shelf    :boolean
#  created_at                 :datetime
#  updated_at                 :datetime
#

class Product &lt; ActiveRecord::Base  
  searchable do
    text :description,
    string :name
    integer :price
    time :created_at
    boolean :is_on_the_shelf
  end
end
</code></pre>

<h2>Step 4. 在controller建立搜尋動作</h2>

<p>接下來，我們會透過controller來取得view的搜尋字，然後把搜尋結果印出</p>

<p>假設我們希望在每一頁上方都有 搜尋bar給使用者做搜尋，在這邊我是假設用product本身的controller來做</p>

<p>在 <strong>app/controllers/products_controller.rb</strong></p>

<pre><code>class ProductsController &lt; ApplicationController
    def search
        @search = Product.search do
            fulltext params[:keyword] do 
              fields(:description, :name =&gt; 2.0)
              query_phrase_slop 1
            end
            with(:is_on_the_shelf, true)
            with(:created_at).less_than(Time.zone.now)
        end
        @products = @search.results
    end
end
</code></pre>

<p>上面是什麼意思呢？</p>

<p>首先，起手式 - 使用搜尋引擎來做等一下的搜尋</p>

<pre><code>@search = Product.search do
            ....
        end
</code></pre>

<p>再來，</p>

<pre><code>fulltext params[:keyword] do 
    fields(:description, :name =&gt; 2.0) 
    # =&gt; 全文搜尋 描述 和 名稱這兩個欄位，而且，名稱的欄位重要度比較高
    query_phrase_slop 1
    # =&gt; 中間有空一個字也成立，所以 “great big pizza” 也會符合 "great pizza這個字"
end
</code></pre>

<p>最後，條件部分：</p>

<pre><code>with(:is_on_the_shelf, true)  
# =&gt; 我要找所有上架的商品
with(:created_at).less_than(Time.zone.now)
# =&gt; 我要找所有建立時間，小於現在時間的商品
</code></pre>

<p>還有一件事：</p>

<pre><code>@products = @search.results 
# =&gt; 這樣會拿到Array 裡頭有預設 30 個 選出的Product
</code></pre>

<h2>Step 5. 在route建立搜尋link</h2>

<p><strong>config/routes.rb</strong></p>

<pre><code>get '/search', to: 'products#search'
</code></pre>

<h2>Step 6. 建立View</h2>

<pre><code>= form_tag search_path, :method =&gt; :get, class: 'search' do
.input-box
  = text_field_tag :keyword, params[:keyword], class: 'input-search'
  = button_tag "搜尋", class: 'icon-search btn btn-primary'
</code></pre>

<h2>Step 7. 恭喜本機端大致完成，只剩跑起來</h2>

<p>注意歐！這邊要做index歐～ 不然不會生效！</p>

<pre><code>rake sunspot:solr:start
rake sunspot:reindex 
</code></pre>

<p>ps. 當你跑完 <strong>rake sunspot:solr:start</strong>後，你會發現產生很多檔案，基本上我只有追蹤</p>

<p><strong>solr/conf/</strong>*底下的設定檔而已</p>

<h2>Step 7-1. 如果在做index時，你有遇到 “illegal character”</h2>

<p>請加上：</p>

<p><strong>config/initializers/sunspot_fix_illegal_chars.rb</strong></p>

<pre><code>module Sunspot
  # 
  # DataExtractors present an internal API for the indexer to use to extract
  # field values from models for indexing. They must implement the #value_for
  # method, which takes an object and returns the value extracted from it.
  #
  module DataExtractor #:nodoc: all
    # 
    # AttributeExtractors extract data by simply calling a method on the block.
    #
    class AttributeExtractor
      def initialize(attribute_name)
        @attribute_name = attribute_name
      end

      def value_for(object)
        Filter.new( object.send(@attribute_name) ).value
      end
    end

    # 
    # BlockExtractors extract data by evaluating a block in the context of the
    # object instance, or if the block takes an argument, by passing the object
    # as the argument to the block. Either way, the return value of the block is
    # the value returned by the extractor.
    #
    class BlockExtractor
      def initialize(&amp;block)
        @block = block
      end

      def value_for(object)
        Filter.new( Util.instance_eval_or_call(object, &amp;@block) ).value
      end
    end

    # 
    # Constant data extractors simply return the same value for every object.
    #
    class Constant
      def initialize(value)
        @value = value
      end

      def value_for(object)
        Filter.new(@value).value
      end
    end

    # 
    # A Filter to allow easy value cleaning
    #
    class Filter
      def initialize(value)
        @value = value
      end
      def value
        strip_control_characters @value
      end
      def strip_control_characters(value)
        return value unless value.is_a? String

        value.chars.inject("") do |str, char|
          unless char.ascii_only? and (char.ord &lt; 32 or char.ord == 127)
            str &lt;&lt; char
          end
          str
        end

      end
    end

  end
end
</code></pre>

<h1>Part 2. 如何利用solmate使用達成sunspot搜尋的推薦字詞</h1>

<p>因為我實在找不太到 sunspot的設定方法，所以我只好用work around的方式做到這件事情</p>

<p>我是使用 solmate這個 gem 來達成自動推薦。</p>

<p>由於solmate是使用redis當作臨時儲存的空間</p>

<p>若是redis 重啟.....那就gg了，你之前建的推薦資料都會不見。</p>

<p>所以，我有另外新建一個model: <strong>Keyword</strong> 去記錄使用者搜尋過的關鍵字</p>

<p>那就開始吧</p>

<h2>Step 1. 加上Gem</h2>

<p>首先，要先加入gem到 <strong>Gemfile</strong></p>

<pre><code>gem 'rack-contrib'
gem 'soulmate', :require =&gt; 'soulmate/server'
</code></pre>

<p>別忘了</p>

<pre><code>bundle install
</code></pre>

<p>再來你要確保你啟用<strong>redis-server</strong></p>

<pre><code>redis-server
</code></pre>

<h2>Step 2. 建立 Keyword model</h2>

<pre><code>rails g model keyword
</code></pre>

<p>然後 migration檔案：(這邊的結構單純就是為了soulmate設計)</p>

<pre><code>class CreateKeywords &lt; ActiveRecord::Migration
  def change
    create_table :keywords do |t|
        t.string :name
        t.integer :score
        t.string :url
        t.string :subtitle
        t.string :keyword_type
      t.timestamps
    end
  end
end
</code></pre>

<p>別忘了</p>

<pre><code>rake db:migrate
</code></pre>

<h2>Step 3. 將使用者輸入的關鍵字，記錄到solmate和keyword model [重要！]</h2>

<p>還記得，剛剛part 1的 Step 4，基本上我們是將下面的code加進去</p>

<pre><code># 如果有搜尋結果我們在記錄關鍵字 
if @products.present?   
    @keyword = Keyword.find_or_create_by(name: "#{params[:keyword]}") do |k|
        k.score = 0
        k.url = "/search?keyword=#{params[:keyword]}"
        k.keyword_type = "Keyword"
    end
    @keyword.update_attribute(:score, @keyword.score+=1) #代表多搜尋了一次
    remove_from_soulmate(@keyword) #先移除soulmate裡面的記錄
    load_into_soulmate(@keyword)    #更新新的紀錄
end

private

def load_into_soulmate(keyword)
    loader = Soulmate::Loader.new("#{keyword.keyword_type}")
    loader.add("term" =&gt; keyword.name, "id" =&gt; keyword.id, "score" =&gt; keyword.score, "data" =&gt; {
  "link" =&gt; "#{keyword.url}"
  })
end

def remove_from_soulmate(keyword)
    loader = Soulmate::Loader.new("#{keyword.keyword_type}")
    loader.remove("id" =&gt; keyword.id)
end
</code></pre>

<p>所以在 <strong>app/controllers/products_controller.rb</strong>，變成了</p>

<pre><code>class ProductsController &lt; ApplicationController
    def search
        @search = Product.search do
            fulltext params[:keyword] do 
              fields(:description, :name =&gt; 2.0)
              query_phrase_slop 1
            end
            with(:is_on_the_shelf, true)
            with(:created_at).less_than(Time.zone.now)
        end
        @products = @search.results

        # 如果有搜尋結果我們在記錄關鍵字 
        if @products.present?   
            @keyword = Keyword.find_or_create_by(name: "#{params[:keyword]}") do |k|
                k.score = 0
                k.url = "/search?keyword=#{params[:keyword]}"
                k.keyword_type = "Keyword"
            end
            @keyword.update_attribute(:score, @keyword.score+=1) #代表多搜尋了一次
            remove_from_soulmate(@keyword) #先移除soulmate裡面的記錄
            load_into_soulmate(@keyword)    #更新新的紀錄
        end

        private

        def load_into_soulmate(keyword)
            loader = Soulmate::Loader.new("#{keyword.keyword_type}")
            loader.add("term" =&gt; keyword.name, "id" =&gt; keyword.id, "score" =&gt; keyword.score, "data" =&gt; {
          "link" =&gt; "#{keyword.url}"
          })
        end

        def remove_from_soulmate(keyword)
            loader = Soulmate::Loader.new("#{keyword.keyword_type}")
            loader.remove("id" =&gt; keyword.id)
        end
        return @products
    end
end
</code></pre>

<h2>Step 4. 當使用者在輸入關鍵字時，進行推薦</h2>

<p>這邊我們需要借助 js了，這邊我就直接copy上面的參考資料了</p>

<pre><code>var ready = function(){
  var render, select;

  render = function(term, data, type) {
    return term;
  }

  select = function(term, data, type){
    // populate our search form with the autocomplete result
    $('#keyword').val(term);

    // hide our autocomplete results
    $('ul#soulmate').hide();

    // then redirect to the result's link 
    // remember we have the link in the 'data' metadata
    return window.location.href = data.link
  }

  $('#keyword').soulmate({
    url: '/autocomplete/search',
    types: ['keyword'],
    renderCallback : render,
    selectCallback : select,
    minQueryLength : 2,
    maxResults     : 10
  })


}
// when our document is ready, call our ready function
$(document).ready(ready);

// if using turbolinks, listen to the page:load event and fire our ready function
$(document).on('page:load', ready);
</code></pre>

<h2>Step 5. 別忘了，補上 JQUERY 和 SOULMATE.JS</h2>

<p>請參考： https://github.com/mcrowe/soulmate.js</p>

<p>下載：https://github.com/mcrowe/soulmate.js/blob/master/src/compiled/jquery.soulmate.js</p>

<p>因為它屬於第三方資源，所以我是把它放在</p>

<p><strong>vender/assets/javascripts/jquery.soulmate.js</strong></p>

<p>另外別忘了在你global的 <strong>app/assets/javascripts/application.js</strong>確保有</p>

<pre><code>//= require jquery
//= require jquery_ujs
//= require jquery.soulmate
</code></pre>

<h2>Step 6. 還有route</h2>

<p><strong>config/routes.rb</strong></p>

<pre><code>mount Soulmate::Server, :at =&gt; "/autocomplete"
</code></pre>

<h2>Step 7. CSS的部分，就請參考</h2>

<p><a href="http://josephndungu.com/tutorials/fast-autocomplete-search-terms-rails">FAST AUTOCOMPLETE SEARCH TERMS - RAILS</a></p>

<p>待續......</p>
]]></content>
  </entry>
  
</feed>
